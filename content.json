{"pages":[{"title":"","text":"","link":"/categories/index.html"},{"title":"","text":"","link":"/tags/index.html"}],"posts":[{"title":"[자료구조] QuickSort(퀵정렬) - Java","text":"1. QuickSort(퀵정렬)1.1 퀵정렬 이란? 배열중에 임의의 한 값을 선택해 그 기준값을 기준으로 작은건 왼쪽, 큰건 오른쪽에 정렬. 문제.2751 [백준] 수 정렬하기 21234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;public class Main { public static void main(String[] args) throws NumberFormatException, IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); int n = Integer.parseInt(br.readLine()); int[] arr = new int[n]; for (int i = 0; i &lt; n; i++) { arr[i] = Integer.parseInt(br.readLine()); } br.close(); quickSort(arr); for (int i : arr) { System.out.println(i); } } public static void quickSort(int[] arr) { sort(arr, 0, arr.length - 1); } private static void sort(int[] arr, int start, int end) { if (start &gt;= end) return; int mid = partition(arr, start, end); sort(arr, start, mid - 1); sort(arr, mid, end); } private static int partition(int[] arr, int start, int end) { int pivot = arr[(start + end) / 2]; while (start &lt;= end) { while (arr[start] &lt; pivot) start++; while (arr[end] &gt; pivot) end--; if (start &lt;= end) { swap(arr, start, end); start++; end--; } } return start; } private static void swap(int[] arr, int i, int j) { int tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp; }} 4,3,2,1,0 배열을 정렬할때 아래 순으로 졍렬된다. 4 3 2 1 0 0 3 2 1 4 0 1 2 3 4","link":"/2019/05/16/tec/algorithm/al2/"},{"title":"[자료구조] MeargeSort(병합 정렬) - Java","text":"1. 병합정렬(MeargeSort)1.1 병합 정렬이란? 정렬할때 가장 작은 단위로 나눠서 정렬후(sort) 병합(mearge)하는 것을 말한다. 문제.2751 [백준] 수 정렬하기 2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;public class Main { public static void mergeSort(int[] arr) { mergeSort(arr, 0, arr.length - 1); } public static void mergeSort(int[] arr, int start, int end) { int[] tmp = new int[arr.length]; if (start &lt; end) { int mid = (start + end) / 2; mergeSort(arr, start, mid); mergeSort(arr, mid + 1, end); mearge(arr, start, mid, end); } } private static void mearge(int[] arr, int start, int mid, int end) { int[] tmp = new int[arr.length]; for (int i = start; i &lt;= end; i++) { tmp[i] = arr[i]; } int part1 = start; int part2 = mid + 1; int index = start; while (part1 &lt;= mid &amp;&amp; part2 &lt;= end) { if (tmp[part1] &lt;= tmp[part2]) { arr[index] = tmp[part1]; part1++; } else { arr[index] = tmp[part2]; part2++; } index++; } for (int i = 0; i &lt;= mid - part1; i++) { arr[index + i] = tmp[part1 + i]; } } private static void printArray(int[] arr) { for (int i : arr) { System.out.println(i); } } public static void main(String[] args) throws NumberFormatException, IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); int n = Integer.parseInt(br.readLine()); int[] arr = new int[n]; for (int i = 0; i &lt; n; i++) { arr[i] = Integer.parseInt(br.readLine()); } br.close(); mergeSort(arr); printArray(arr); }} 4,3,2,1 배열을 정렬할때 아래 순으로 졍렬된다. 4 3 2 1 3 4 2 1 3 4 1 2 1 2 3 4","link":"/2019/05/16/tec/algorithm/al1/"},{"title":"[알고리즘] 1. 정렬 기초(선택정렬, 삽입정렬, 버블정렬)","text":"1.정렬 오름차순, 내림차순 1.1 정렬의 종류 선택정렬 삽입정렬 버블정렬 1.1.1 선택정렬 예시 배열을 순서대로 탐색하면서 최소값을 앞으로 이동시킴 0) 주어진 배열 2 5 6 7 1 3 1) 첫번째 정렬(1과 2 자리변경) 1 5 6 7 2 3 2) 두번째 정렬(배열2부터 최소값찾기/2와 5자리 변경) 1 2 6 7 5 3 3) 세번째 정렬(배열3부터 최소값찾기/3와 6자리 변경) 1 2 3 7 5 6 4) 네번째 정렬(배열4부터 최소값찾기/5와 7자리 변경) 1 2 3 5 7 6 5) 다섯번째 정렬(배열5부터 최소값찾기/6와 7자리 변경) 1 2 3 5 6 7 6) 선택정렬끝!!1.2.1 삽입정렬 기준 배열과 나머지 배열 비교하여 작은것 것을 앞으로 바꿈 ex) 0) 주어진 배열 2 5 9 1 6 1) 첫번째 정렬(2와 5비교 유지) 2 5 9 1 6 (2와 9비교 유지) 2 5 9 1 6 (2와 1비교 1과 2위치 변경) 1 5 9 2 6 (1과 6비교 유지) 1 5 9 2 6 2) 두번째 정렬(배열2부터 최소값찾기/2와 5자리 변경)(5와 9비교 유지) 1 5 9 2 6 (5와 2비교 자리변경) 1 2 9 5 6 (2와 6비교 유지) 1 2 9 5 6 3) 세번째 정렬(배열3부터 최소값찾기/3와 6자리 변경)(5와9비교 유지) 1 2 5 9 6 (5와 6비교 유지) 1 2 5 9 6 4) 네번째 정렬(배열3부터 최소값찾기/3와 6자리 변경)(9와9비교 변경) 1 2 5 6 9 5) 삽입정렬끝!!1.3.1 버블정렬 인접한 두 원소 비교 해서 큰 수를 뒤로 보냄 ex) 0) 주어진 배열 3 2 5 1 4 1) 첫번째 정렬(3과 2비교 자리 바꿈) 2 3 5 1 4 (3과 5비교 유지) 2 3 5 1 4 (5와 1비교 자리 변경) 2 3 1 5 4 (5와 4비교 변경 &gt; 5자리 확정) 2 3 1 4 5 2) 두번째 정렬(2와 3비교 유지) 2 3 1 4 5 (3와 1비교 자리변경) 2 1 3 4 5 (3와 4비교 유지 &gt; 4자리 확정) 2 1 3 4 5 3) 세번째 정렬(2와1비교 변경) 1 2 3 4 5 (2와 3비교 유지 &gt; 3자리 확정) 1 2 3 4 5 4) 네번째 정렬(1와2비교 유지 &gt; 2자리 확정) 1 2 3 4 5 5) 버블정렬끝!!","link":"/2019/12/01/tec/algorithm/al3/"},{"title":"[알고리즘] 3. 정수(Integer)","text":"1. 정수1.1 약수 특정 수를 나누어 떨어지게 하는 수 1.1.1 약수 구하기 구현1.2 소수 약수가 1과 자기자신인 수 1.2.1 소수 구하기 구현1.2.2 에라토스테네스의 체(소수 구하기) 구현1.3 소인수 분해숫자N을 소수의 곱으로 나타냄 1.3.1 구현1.4 공약수와 공배수 A,B 공약수, A와 B의 공통된 약수AB 공배수 A와 B의 공통된 배수 1.4.1 최대공약수(GCD), 최소공배수(LCM)1.4.2 유클리드 호제법 a, b, r(a/b)b, r(a/b) , r(b, r(a/b))… a, b, r==0일때, b 가 최대공약수 1.4 파스칼 삼각형12345112113313C0, 3C1, 3C2, 3C314641 콤비네이션 값 구할때 사용(20C11)","link":"/2019/12/03/tec/algorithm/al5/"},{"title":"[알고리즘] 2. 시간복잡도","text":"1. 시간복잡도 문제가 얼마나 빠르게 해결되는지 나타냄대략적으로 몇개의 명령을 수행하는지? 1.1 for문123for(int i=0 ; i&lt;n; i++){ int a=0;} int a=0;명령을 n번 수행 &gt;&gt; 시간복잡도 O(n) 1.2 n*n 이중for문12345for(int i=0 ; i&lt;n; i++){ for(int j=0 ; j&lt;n; j++){ int a=0; }} int a=0;명령을 n*n번 수행 &gt;&gt; 시간복잡도 O(n^2) 1.3 n(n-1)(n-2) …2*1 이중for문12345for(int i=0 ; i&lt;n; i++){ for(int j=0 ; j&lt;i; j++){ int a=0; }} int a=0;명령을 n(n-1)/2번 수행 &gt;&gt; 1/2nn &gt;&gt; 상수는 무시 &gt;&gt; 시간복잡도 O(n^2) 1.4 if절 있는 for문12345for(int i=0 ; i&lt;n; i++){ if(i==1){ int a=0; }} 최악의 경우 n번 수행(if절 결과에 따라) &gt; O(N)최고차항만 체크 2. 입력크기에 따른 수행시간 n의 입력 값에 따라 수행시간 다름 컴퓨터 사양에 따라 다름 2.1 O(N) 시간복잡도 n이 9000만개일때 보통 1초 2.2 O(N^2) 시간복잡도 n이 10000개일때 보통 1초 &gt; 명령어 실행수 대략 1억에 1 3. 정렬의 시간복잡도3.1 선택정렬 최소값 1번 찾는데 O(N)번 * N번 &gt; O(n^2) 3.2 삽입정렬 원소 하나 삽입 시 O(N)걸림 * N번 &gt; O(n^2) 3.3 버블 정렬 인접한 원소 비교해서 뒤로 보냄 O(n) 걸림 * n번 &gt; O(n^2) 선택, 삽입, 버블 정렬은 시간복잡도가 안 좋은편!!","link":"/2019/12/02/tec/algorithm/al4/"},{"title":"[알고리즘] 4. 재귀함수","text":"1. 재귀함수 자기자신을 부르는 함수 1.2 재귀함수가 의미있는 예제 펙토리얼 n! = n(n-1)(n-2)…*11234int getFactorial(int n){ if(n==1) return 1; else return n*getFactorial(n-1);} 함수 호출 흐름 main에서 getFactorial(3) 호출된다고 가정. getFactorial(3)에서 3*getFactorial(2)리턴 getFactorial(2)에서 2*getFactorial(1) 리턴 getFactorial(1)에서 1리턴 123 도출 1.2 두가지 계산반벙1.2.1 순차적 계산방법A를 계산, A를 이용해서 B를 계산, B를 이용해서 C를 계산..n!=n(n-1)…1 1.2.2 귀납적 계산방법구하려고 하는 값은 f(x) f(x)를 구하기 위해 또 f(x)를 활용함n!= 5f(4)n!=54f(3)…n! = 5432*f(1) n의 m제곱을 귀납적으로 정의n^m = nn^(m-1)…n^m = nnn..n^0 1.3 수납적 귀납법명제 p(n)이 모든 n에 성립함을 증명.p(k)가 성립한다고 가정후 p(k+1)이 성립함을 증명. 2 재귀함수 디자인2.1 3가지 절차1) 함수의 역할을 명확하게 정의2) 기저조건에서 함수가 제대로 동작함을 보임3) 함수가 제대로 동작한다고 가정하고 함수를 완성2.2 재귀함수 구현2.2.1 n의 m제곱1) getPower(n,m)은 n의 m승을 반환하는 함수이다.ex) getPower(2,4)=16 2) 기저조건 getPower(n,0)=13) getPower(n,m)=n * getPower(n, m-1)2.2.2 이진수 출력하기1) pringBin(x)는 X를 이진수로 바꿔출력하는 함수2) 기저조건 printBin(1)=1, printBin(0)=03) printBin(x)={ print(x/2); print(x%2);}2.2.3 펠린드롬인지 판별하기 펠린드롬은 좌우 대칭인 값을 말함1) isPal(String, start, end)2) 기저조건: start==end isPal(String, start, end)=true;3) isPal(String, start, end)if(String.start==String.end) return isPal(String, start+1, end-1);else return false;","link":"/2019/12/04/tec/algorithm/al6/"},{"title":"[알고리즘] 5. 고급 정렬(합병정렬, 퀵정렬)","text":"1. 로그 개념과 효율성log2 16=4;logx y = N;x^n=y;nlog n &lt;- n이커질수록 o(n)과 속도 차이가 크다 2. 고급정렬 종류2.1 합병정렬 정렬할 값을 반으로 나눠 각각 정렬 후 두 정렬을 크기순으로 합침 2.1.1 고급정렬 예제1) 아래 배열 정렬 4 14 8 23 11 2) 반으로 나누기-&gt;각 값이 하나씩 있을때까지 4 14 8 3 23 11 4 14 8 3 23 11 4 14 8 3 23 11 3) 각각 크기순으로 배열 합치기 4 14 8 3 23 11 4 8 14 3 11 23 3 4 8 11 14 23 2.1.2 합병정렬 시간복잡도1) 왼쪽 /오른쪽 합병정렬 T(n/2) +T(n/2) =&gt; n2) 두 배열 합치기 o(n)3) T(n)=2*T(n/2)+O(n)이걸 풀면…T(n)=O(nlogn) 2.1.3 합병정렬 재귀함수 디자인1) 함수 정의2) 기저조건 s&gt;=e이면 retrun3) mearge(arr, s, e)mearge(arr, s, mid)mearge(arr, mid+1, e) 2.1.4 합병정렬 구현12 2.2 퀵정렬 임의의 값 하나를 기준으로 기준값보다 큰건 오른쪽 작은건 왼쪽으로 보내기 2.2.1 예시1) 아래 배열 퀵정렬 3 1 5 4 2 2) 배열 제일 앞숫자3 기준 정렬 1 2 3 5 4 3-1) 3기준 앞 배열 제일 앞 숫자1로 정렬 1 2 3 5 4 3-2) 3기준 뒤 배열 중 가장 앞 숫자 5기준으로 정렬 1 2 3 5 4 2.2.2 퀵정렬 시간복잡도평균적으로는 O(nlogn) 가장 오래 걸리면 O(n^2) 2.2.3 퀵정렬 구현12 2.3 힙정렬 트리구조를 이용한 정렬 나중에 나옴!","link":"/2019/12/05/tec/algorithm/al7/"},{"title":"[알고리즘] 6. 자료구조","text":"1. 자료구조 기본1.1 컴퓨터 기본 커리큘럽1.1.1 기본언어1.1.2 자료구조1.1.3 알고리즘1.2 자료구조란? 데이터를 담는 구조 1.3 기본 자료 구조1.3.1 변수 int x=4; 1.3.2 배열 int[] arr={0,1,2}; 장점: arr[i]번째 수를 바로 일 수 있음. 딘잠: 데이터 넣고 빼기가 힘듬(배열 앞뒤로 다 이동시키고 삽입)1.3.3 링크드 리스트 앞의 값이 다음 값을 알고있음 장점: 데이터 넣고 빼기 용이 x[i]번째 값 알기 어려움(처음부터 탐색) 2. 기초 자료구조 자료구조가 설계된 목적을 이해해야함 스택 큐 트리 그래프 2.1 스택(Stack) 선형 자료구조 in/out LIFO(Last in first out) push(), .pop(), 스택 오버플로우란 push()할때 할당된 공간이 다 차서 넘치는것 스택언더플로우란 공간에 데이터가 하나도 없을때 pop()하는것 2.1.1 스택 구현 push() pop() top() size() 2.2 큐(Quque) &lt;-out &lt;- in FIFO(First in first out) push(), .pop(), 스택 오버플로우란 push()할때 할당된 공간이 다 차서 넘치는것 스택언더플로우란 공간에 데이터가 하나도 없을때 pop()하는것 큐의 문제점 : 공간활용이 안좋음 &gt;&gt; 해결 원형큐 2.2.1 원형큐배열 공간을 원형으로 만들어서 함 2.2.2 큐 활용문제 예시괄호가 올바른지 판단하기 2.3 트리(Three) root 노드(정점) 간선 트리의 재귀적성질 2.3.1 트리순회 전위순회 : root-Left-Right 중위순회 : Left-Root-Right 후위순회 : Left-Right-Root 2.4 우선순의 큐 큐에 넣고 우선순위가 높은것 순으로 뽑기 배열을 이용한 우선순의 큐는 뽑고 다시채워야 해서 O(n^2)걸림-&gt;느림 2.4 힙(Heap) 부모값이 항상 자식보다 작은 이진트리 아래 트리에 4를 추가한다고 하면. 3 5 7 23 7 9 null –4추가 3 5 7 23 7 9 4 4랑 7비교 4랑 7변경 3 5 4 23 7 9 7 4랑 3비교 유지 &gt; 정렬끝!! 3 5 4 23 7 9 7 2.4.1 힙의 삽입의 시간복잡도완전 이진트리의 높이 노드수 높이 1 1 2 2 3 2 4 3 5 3 6 3 7 3 8 4 노드의 개수가 n개일때의 높이 = logn 2^n-1 힙 값 삽입의 시간복잡도=&gt; O(logn) 힙 값 삭제의 시간복잡도 =&gt; O(logn)","link":"/2019/12/06/tec/algorithm/al8/"},{"title":"[JEKYLL과 깃허브로 블로그 만들기] 지킬 테마 복사하기","text":"1. 닉네임.github.io 레포지토리 만들기위와 같이 닉네임.github.io 이름으로 public 레포지토리를 만듭니다. 2. 사용할 템틀릿 정하기여기서(jekyll-theme){: target=”_blank”} 원하는 테마프로젝트를 선택합니다. minimal-mistakes 테마를 선택하였습니다. 3. _config.yml 파일 복사하기remote_theme : mmistakes/minimal-mistakes추가 및 수정하기 4.index.html 복사하기1---layout: home--- 위와 같이 index.html파일을 만듭니다.","link":"/2019/04/08/tec/blog/blog1/"},{"title":"[Hexo와 깃허브로 블로그 만들기] 블로그에 Google Analytics 설치하기","text":"1. 구글 애널리틱스 사이트에 계정만들기google analytics 회원가입 하러가기 2. GA홈에서 관리할 사이트 계정을 추가한다. 관리 클릭 계정만들기 클릭 정보 넣고 추적ID가져오기 클릭 추적 아이디 값 복사하기 3. /blog/themes/icarus/_config.yml 파일 수정123plugins: google-analytics: tracking_id: XXXXXX (required) 4. 사용자 분석구글 애널리틱스 사용자 분석하러 가기","link":"/2019/04/17/tec/blog/blog10/"},{"title":"[JEKYLL과 깃허브로 블로그 만들기] 콜렉션(Collection)만들기","text":"1. /_config.yml파일 수정하기1234collections: trip: output: true permalink: /:collection/:path/ 위의 내용 추가 1234567891011defaults: # _trip - scope: path: &quot;&quot; type: trip values: layout: single author_profile: false share: true related: true 위의 내용 추가 2. _pages/trip-archive.md 파일 만들기12345678910---title: 여행layout: collectionpermalink: /trip/collection: tripentries_layout: gridclasses: wide--- 3._/trip/post1.md 파일 만들기123456789101112131415161718192021222324252627282930313233itle: &quot;Trip1&quot;excerpt: &quot;첫번째 여행글 입니다..&quot;header: image: /assets/images/별그림.png #teaser: assets/images/unsplash-gallery-image-1-th.jpgsidebar: - title: &quot;Role&quot; image: /assets/images/별그림.png image_alt: &quot;logo&quot; text: &quot;Designer, Front-End Developer&quot; - title: &quot;Responsibilities&quot; text: &quot;Reuters try PR stupid commenters should isn&apos;t a business model&quot;gallery: - url: /assets/images/별그림.png image_path: /assets/images/별그림.png alt: &quot;placeholder image 1&quot; - url: /assets/images/unsplash-gallery-image-2.jpg image_path: /assets/images/별그림.png alt: &quot;placeholder image 2&quot; - url: /assets/images/unsplash-gallery-image-3.jpg image_path: /assets/images/별그림.png alt: &quot;placeholder image 3&quot;categories: [아시아, 한국, korea]tags: [hot, summer]---이사진은 별그림 입니다{% include gallery caption=&quot;This is a sample gallery to go along with this case study.&quot; %}이건 마지막 글입니다.ude gallery caption=&quot;This is a sample gallery to go along with this case study.&quot; %} 4. 완성참고:https://jekyllrb-ko.github.io/docs/collections/","link":"/2019/04/10/tec/blog/blog3/"},{"title":"[Markdown] Markdown 문법 정리","text":"1. Header글머리 1 ~ 6123456# This is a H1## This is a H2### This is a H3#### This is a H4##### This is a H5###### This is a H6 This is a H1This is a H2This is a H3This is a H4This is a H5This is a H6 2. 굵게 기울임꼴 텍스트2.1 굵게 지정하려면 두개의 별표로 묶습니다.1This text is **bold**. This text is bold. 2.2 기울임꼴로 지정하려면 한개의 별표로 묶습니다.1This text is *italic*. This text is italic. 2.3 굵게 기울임꼴로 지정하려면 세개의 별표로 묶습니다.1This text is ***bold and italic***. This text is bold and italic. 3. BlockQuote1&gt; This is a BlockQuote This is a BlockQuote This is a BlockQuote This is a BlockQuote 이 안에서도 마크다운 요소를 사용할 수 있습니다. > - List > 12&gt; BlockQuote&gt; List12&gt; BlcokQuote&gt; 4. List4.1 순서 있는 목록어떤 번호를 넣더라도 내림차순으로 숫자가 지정됩니다.1231. 첫번쨰3. 두번째2. 세번째 첫번째 두번째 세번째 다른 목록 안에 목록을 중첩하려면 항목을 들여씁니다. 12341. 첫번쨰 1. 두번째 1. 세번째1. 네번째 첫번째 두번째 세번째 네번쨰 4.2 순서 없는 목록1234567891011* 빨강 * 녹색 * 파랑+ 빨강 + 녹색 + 파랑- 빨강 - 녹색 - 파랑 빨강 녹색 파랑 빨강 녹색 파랑 빨강 녹색 파랑 5. Table파이프(|) 및 하이픈(-)을 이용하여 테이블을 만들 수 있습니다.하이픈으로는 헤더를 만들며 파이프로는 각 열을 만듭니다.하이픈으로 헤더 구분시 좌측에 콜론(:)을 삽입 할 경우 좌측정렬 우측에 삽입 할 경우 우측정렬이 되며 양쪽에 둘 경우 가운데 정렬이 됩니다. 123456| Fun | With | Tables || :------------------- | -------------------: |:---------------:|| left-aligned column | right-aligned column | centered column || $100 | $100 | $100 || $10 | $10 | $10 || $1 | $1 | $1 | Fun With Tables left-aligned column right-aligned column centered column $100 $100 $100 $10 $10 $10 $1 $1 $1 6. 링크6.1. 참조 링크syntax: [id]: Link[title][id] 123456[hscodev]: hsco.dev[github]: https://github.com/hscodev[블로그][hscodev][깃허브][github] 블로그 깃허브 6.2. 인라인 링크syntax: [Label](Link) 1[블로그](https://hsco.dev) 블로그 6.3. 자동연결syntax: \\ 1&lt;https://hsco.dev&gt; https://hsco.dev 7. 코드개발 코드를 코드블록으로 배치 할 수 있습니다.alias 별칭을 이용하여 구문 강조가 가능합니다. 이름 Alias java java json json javascript javascript html html markdown md SQL sql 등 1your code goes in here 8. 이미지12![Alt text](/assets/images/duck.jpg)![Alt text](/assets/images/duck.jpg &quot;별그림&quot;)","link":"/2019/08/05/tec/blog/blog11/"},{"title":"[JEKYLL과 깃허브로 블로그 만들기] 네비게이션 메뉴 (Navigation)만들기","text":"1. /_data/navigation.yml 파일 만들기1234567main: - title: &quot;TECHNOLOGY&quot; url: /tec/ - title: &quot;WORLD-TRIP&quot; url: /trip/ - title: &quot;OTHERS&quot; url: /posts/ 위의 내용 추가 2. 완성","link":"/2019/04/11/tec/blog/blog4/"},{"title":"[Hexo와 깃허브로 블로그 만들기] 블로그에 layout 만들어 빠른 포스팅 하기","text":"1. /scaffolds 파일 아래 blog.md 파일을 만든다.원하는 형식으로 Front-Matter부분을 수정한다.123456789101112---title: {{ title }}categories: [tec, blog]tags: [blog, tec, hexo, github] toc: truedate: {{ date }}--- 2. 커멘드 창에서 (프로젝트 위치아래에서) 아래와 같이 명령어를 입력한다.1$ hexo new blog -p tec/blog/blog13 &quot;레이아웃 만들기&quot; blog: 아까 scaffolders에서 만든 레이아웃 파일명 -p: 경로명 “레이아웃만들기”: title안에 들어갈 내용명령어 옵션 참고 3. /source/_posts/tec/blog/blog13.md 파일이 생성된 것을 확인 할 수있다.12345678910---title: &quot;레이아웃 만들기&quot;categories: [tec, blog]tags: [blog, tec, hexo, github, google-analytics]toc: true date: 2019/10/18 13:09:23 --- 4. 해당 파일에 원하는 글을 써서 배포한다.","link":"/2019/10/18/tec/blog/blog12/"},{"title":"[JEKYLL과 깃허브로 블로그 만들기] 포스트(Post) 쓰기","text":"1. /_posts/2019-01-01.md파일 생성하기12345678910---title: &quot;테스트 포스팅&quot;date: 2017-10-20 08:26:28 -0400categories: - testtags: - test---## 안녕하세요. 2. 완성","link":"/2019/04/09/tec/blog/blog2/"},{"title":"[Hexo와 깃허브로 블로그 만들기] jykell에서 hexo로 블로그 이전하기","text":"hexo테마가 이쁜게 많아서 바꾸기로 함. 1. Node.js설치nodejs 설치하러 가기 2. Git 설치git 설치하러 가기 3. Hexo 설치hexo 설치하러 가기 1$ npm install -g hexo-cli 4. 블로그 시작하기git bash쉘에서 블로그 프로젝트를 구성할 디렉터리 위치에 가서 아래와 같이 실행한다. 123$ hexo init blog$ cd blog$ hexo server hexo server가 http://localhost:4000 으로 실행됨. 5. blog/_config.yml 파일 수정하기1234567url: http://yoursite.com deploy: type: git repo: https://github.com/crlo2/crlo2.github.io.git branch: master deploy 항목을 저렇게 수정하면 hexo가 명령어로 자동 배포 및 생성을 해준다. 6. hexo deployer 설치1$ npm install hexo-deployer-git --save 7. hexo 생성 및 git 레포지토리에 배포12$ hexo clean$ hexo d -g 이렇게 배포를 해줘야만 https://clro2.github.io 주소로 접속하면 블로그 화면이 보인다.","link":"/2019/04/13/tec/blog/blog6/"},{"title":"[JEKYLL과 깃허브로 블로그 만들기] 검색 메뉴(Search)만들기","text":"1. /_config.yml 파일 수정하기1search: true 위의 내용 추가 2. 완성","link":"/2019/04/12/tec/blog/blog5/"},{"title":"[Hexo와 깃허브로 블로그 만들기] Hexo 테마 적용","text":"1. Hexo 테마 고르기Hexo 이쁜 테마 고르러 가기 2. icarus 테마 적용하기블로그 프로젝트 경로($ cd ~/blog/) 아래 blog/themes/icarus 폴더를 만들어 git 테마를 clone한다. 1$ git clone https://github.com/ppoffice/hexo-theme-icarus.git themes/icarus 3. ~/blog/themes/icarus/_config.yml 파일에서 theme 설정을 icarus로 변경한다.1theme: icarus 4. hexo 서버 재시작 한다.1$ hexo s localhost:4000에서 적용된 테마를 확인한다. 5. github에 배포한다.12$ hexo clean$ hexo d -g","link":"/2019/04/14/tec/blog/blog7/"},{"title":"[Hexo와 깃허브로 블로그 만들기] disque로 댓글 기능 활성화 하기","text":"1. disque 회원가입disque 회원가입 하러가기 2. UserName변경Account에서 Username을 변경한다.(disque에서 유일해야함.) 3. /blog/themes/icarus/_config.yml 파일 수정123comment: type: disqus shortname: xxxxxxxx 4. post.md 파일 Front-Matter부분 수정1234# (optional) a unique id to identify the post in Disqus systemdisqusId: xxxxxxxx---Post content...","link":"/2019/04/16/tec/blog/blog9/"},{"title":"[CH6. 객체지향프로그래밍1] 클래스와 객체","text":"1. 객체지향 언어 코드의 재사용성이 높다. 코드의 관리가 용이하다. 신뢰성이 높은 프로그래밍을 가등하게 한다. 2. 클래스와 객체2.1 클래스와 객체의 정의와 용도클래스: 객체를 정의 해놓은것으로 객체를 생성할때 사용한다. 클래스 객체 제품설계도 제품 TV설계도 TV 붕어빵 기계 붕어빵 2.2 객체와 인스턴스클래스 —(인스턴스화)—&gt; 인스턴스(객체) 2.3 객체의 구성요소 - 속성과 기능12속성(propertiy) - 맴버변수(member variable), 특성(attribute), 필드(field), 상태(state) 기능(function)- 매서드(method), 행위(behavior), 함수(function) TV의 속성과 기능 속성 기능 크기, 길이, 높이, 색상, 볼륨, 채널 등 켜기, 끄기, 볼륨 높이기, 볼륨 낮추기, 채널 변경하기 속성-&gt; 맴버변수기능-&gt;매서드 TV 클래스1234567891011class Tv { //Tv의 속성(맴버변수) String color; boolean power; int channel; //Tv의 기능(매서드) void power(){ power=!power;} void channelUp(){++channel;} void channelDowun(){--channel;} } 2.4 인스턴스의 생성과 사용클래스 변수명; // 클래스의 객체를 참조하기 위한 참조변수를 선언한다.변수명 = new 클래스명(); // 클래스의 객체를 생성 후 , 객체의 주소를 참수변수에 저장한다. Tv t;t = new Tv(); TvTest.java123456789101112131415161718192021class Tv { //Tv의 속성(맴버변수) String color; boolean power; int channel; //Tv의 기능(매서드) void power(){ power=!power;} void channelUp(){++channel;} void channelDowun(){--channel;} }class TvTest{ public static void main(String args[]){ Tv t; // 메모리에 참조변수 t의 공간 생김 t = new Tv(); // t에 객체 주소값이 저장, 메모리 공간에 TV 클래스 인스턴스가 생김 t.channel = 7; //t에 저장된 주소에 있는 인스턴스 멤버변수 channel에 7저장 t.channelDown(); //t가 참조하는 Tv인스턴스 channelDowun매서드 호출-&gt;channel1감소 }} 2.5 클래스의 또 다른 정의 클래스 - 데이터와 함수의 결합 변수 - 하나의 데이터를 저장할 수 있는 공간 배열 - 같은 종류의 여러 데이터를 하나의 집합으로 저장할 수 있는 공간 구조체 - 서로 관련된 여러 데이터를 종류에 관계없이 하나의 집합으로 저장할 수 있는 공간 클래스 - 데이터와 함수의 결합(구조체+함수) 클래스 - 사용자 정의 타입 서로 관련된 변수를 묶어서 하나의 타입으로 새로 추가123int hour;int minute;float second; 12345class Time{ int hour; int minute; float second; }","link":"/2019/05/01/tec/java/java1/"},{"title":"[Hexo와 깃허브로 블로그 만들기] Hexo 블로그 포스트 쓰기","text":"1. ~/blog/source/_posts/ 아래에 postname.md 파일 만들기.파일을 만든 후 아래 내용을 입력한다. 1234567891011---title: &quot;[Hexo와 깃허브로 블로그 만들기] Hexo 블로그 포스트 쓰기&quot;categories: [test]tags: [test]---## Hello World! 2. jekyll 포스트 hexo로 옮기기jekyll migratorn 참고 링크 지킬 프로젝트에서 _posts/하위 폴더 다 복사 후 hexo 프로젝트 /source/_posts/에다 붙여넣기. 포스트 제목을 2019-01-01-name.md의 형식을 name.md로 변경. 포스트 내용의 Front-matter 부분을 알맞게 수정 포스트안에 이미지나 다른 첨부 내용이 있다면 같이 옮겨줌. 지킬의 /assests/images/ 폴더를 hexo의 blog/source/assets/images 로복사해줌 이미지 첨부가 맞지 않을 경우 hexo 서버가 에러가 남.","link":"/2019/04/15/tec/blog/blog8/"},{"title":"[CH7. 객체지향프로그래밍2] 인터페이스의 ","text":"7. 인터페이스7.1 인터페이스란?인터페이스는 일종의 추상클래스.추상클래스처럼 추상메서드를 갖지만 추상클래스보다 추상화 정도가 높아서추상클래스와 달리 몸통을 갖춘 일반 메서드 또는 멤버변수를 구성원으로 가질 수 없다. 7.2 인터페이스의 작성1234interface 인터페이스이름{ public static final 타입 상수이름 = 값; public abstract 메서드이름(매개변수 목록);} 모든 멤버변수는 public static final 이어야 하며, 이를 생략할 수 있다. 모든 메서드는 public abstract 이어야하며, 이를 생략할 수 있다. 7.3 인터페이스의 상속인터페이스는 인터페이스로부터만 상속받을 수 있으며, 클래스와는 달리 다중상속이 가능하다. 12345678interface Movable{ void move(int x, int y);}interface Attactable{ void move(Unit u);}interface Fightable extends Movable, Attackable{} 7.4 인터페이스의 구현그 자체로는 인스턴스를 생성할 수 없음. 클래스에서 implements를 사용하여 구현함. 1234567891011class 클래스 이름 implements 인터페이스이름{ //인터페이스에 정의된 추상메서드 구현}class Figther implements Fightable{ public void move(int x, int y){ //기능 구현 } public void attack(Unit u){ //기능 구현 }} 구현하는 인터페이스의 메서드 중 일부만 구현하면 추상메서드로 선언되어야 함.12345abstract class Fighter implements Figtable{ public void move(int x, int y){ //기능 구현 }} 상속과 구현을 동시에 할 수 있음12345678class Figther extends Unit implements Figthable{ public void move(int x, int y){ //기능 구현 } public void attack(){ //기능 구현 }} 7.5 인터페이스를 이용한 다중상속자바에서는 다중상속을 허용하지 않아서 인터페이스로 다중상속을 할 수는 있지만 거의 하지 않는다.두개의 클래스를 상속받아야 하는 상황이라면 두 클래스중 비중이 높은걸 상속받고 나머지는 클래스 내부 멤버로 포함시키는 방법.필요한 부분을 뽑아 인터페이슬슬 만든 후 구현함. 7.6 인터페이스를 이용한 다형성인터페이스 타입의 참조변수로 이를 구현한 클래스의 인스턴스를 참조할 수있고 형변환도 가능함.인터페이스 : Fightable, 클래스 : Fighter(implements Figtable)일때12Fightable f = (Fightable) new Figther();Fightable f = new Fighter(); 인터페이스는 매게변수 타입으로도 쓸 수 있음1viod attack(Figtable f){} 메서드 호출 시 해당 인터페이스를 구현한 클래스의 인스턴스를 매개변수로 제공해야한다.여기서는 new Figther();리턴타입으로 인터페이스 타입을 지정하는것도 가능함.1234Fightable method(){ // ... return new Fighter();} 7.7 인터페이스의 장점 개발시간을 단축시킬 수 있다. 표준화가 가능하다. 서로 관계업는 클래스들에게 관계를 맺어줄 수 있다. 독립적인 프로그래밍이 가능하다. 7.8 인터페이스의 이해 클래스를 사용하는 쪽과 클래스를 제공하는 쪽이 있다. 메서드 사용하느 쪽에서는 사용하려는 메서드의 선언부만 알면된다.","link":"/2019/05/07/tec/java/java10/"},{"title":"[CH6. 객체지향프로그래밍1] 변수와 메서드","text":"3. 변수와 매서드3.1 선언위치에 따른 변수의 종류 변수의 종류 선언위치 생성시기 클래스변수 클래스 영역 클래스가 메모리에 올라갔을 때 인스턴스 변수 클래스 영역 인스턴스가 생성되었을때 지역변수 클래스 영역 이외의 영역 (메서드, 생성자, 초기화 블럭 내부) 변수 선언문이 수행되었을때 12345678class Variables{ int iv; //인스턴스 변수 static int cv; //클래스 변수(static 변수, 공유변수) void method(){ int iv; // 지역변수 }} 인스턴스 변수 클래스 영역에 선언, 인스턴스 생성때 만들어짐 클래스 변수 인스턴스 앞에 static을 붙임.한 클래스의 모든 인스턴스들이 공통적 값을 유지해야 되는 경우 사용.public을 붙이면 프로그램 내 전역에서 사용가능 지역 변수 매서드 내 선언. 메서드 내에서만 사용가능. 메서드 종료시 소멸. 3.2 클래스변수와 인스턴스 변수 123456 class Card { String kind; // 카드 무늬 - 인스턴스변수 int number; // 카드 숫자 - 인스턴스 변수 static int width = 100; // 카드 폭 - 클래스 변수 static int height = 250; //카드 높이 -클래스 변수} 인스턴스 변수는 인스턴스가 생성될 때마다 각기 다른 값을 유지,클래스 변수는 모든 인스턴스가 하나의 저장공간을 공유해서 항상 공통된 값 가짐 3.3 메서드 하나의 메서드는 되도록 하나의 기능만 수행하도록 하는것이 좋다. 반복적으로 수행되야 하는 여러 문장을 하나의 메서드로 정의해놓으면 좋다 관련된 여러 문장을 하나의 메서드로 만들어 놓는 것이 좋다. 3.4 return 문 메서드가 정상적으로 종료되는 경우 메서드의 블럭{}내의 마지막 문장을 수행했을 때 메서드의 블럭{}내에 있는 문장을 수행중 return 문을 만났을때. return 문은 실행중인 메서드를 종료 후 호출 메서드로 되돌아감 반환값이 없는 경우 : return; 반환값이 있는 경우 : return 반환값; 3.5 메서드의 호출참조변수.메서드이름();참소변수.메서드이름(값1, 값2, ..); 3.6 JVM의 메모리 구조 Method Area(메서드영역)클래스/데이터 Call Stack(호출스택)Main Heap(힙)인스턴스 3.7 기본형 매개변수와 참조형 매개변수기본형 매개변수 - 변수의 값 읽기만 할 수 있음참조형 매개변수 - 변수의 값을 읽고 변경 할 수 있음. 3.8 재귀호출f(n) = n* f(n-1) 3.9 클래스(static 메서드)와 인스턴스메서드 클래스 설계할 때, 멤버 변수 중 모든 인스턴스에 공통적으로 사용해야하는 것에 static 을 붙인다. 클래스 변수(static변수)는 인스턴스를 생성하지 않아도 사용할 수 있다. 클래스 메서드는 인스턴스 변수를 사용할 수 없다. 메서드 내에서 인스턴스 변수를 사용하지 않는다면, static을 붙이는 것을 고려한다. 3.10 클래스멤버와 인스턴스멤버간의 참조와 호출인스턴스 멤버가 존재할때는 클래스멤버는 항상 존재하지만,클래스맴버가 존재하는 시점에 인스턴스멤버가 존재할수도 있고 없을수도 있음.","link":"/2019/05/01/tec/java/java2/"},{"title":"[CH15. 네트워킹(Networking)] 네트워킹","text":"1.네트워킹두대 이상의 컴퓨터를 케이블로 연결하여 네트워크를 구성하는것. 1.1 클라이언트/서버(client/server)서버(server)는 서비스를 제공하는 컴퓨터, 클라이언트(client)는 서비스를 사용하는 컴퓨터.ex) 파일서버(file server), 메일서버(mail server), 어플래케이션 서버(application server) 서버기반 모델(server-based-model) P2P모델(peer-to-peer model) - 안정적인서비스 제공이 가능하다.- 공유데이터의 관리와 보안이 용이하다.- 서버구축비용과 관리비용이 든다. - 서버구축 및 운용비용을 절감할 수 있다. - 자원의 활용을 극대화 할 수 있다. - 자원의 관리가 어렵다. - 보안이 취약하다. 1.2 IP주소(IP address)IP주소는 컴퓨터(호스트, host)를 구별하는데 사용하는 고유한 값.4 byte(32bit)의 정수로 구성되어있음. a.b.c.d와 같은 형식으로 표현됨.abcd는 0~255사이의 정수이다.윈도우 콘솔에서 ifconfig를 확인하면 ip주소를 확인 할 수 있음.ex) ip주소192.168.10 .100(네트워크주소).(호스트주소) 서브넷마스크255.255.255.0 1.3 InetAddress자바에서 IP주소를 다루기 위한 클래스로 InetAddress 제공함 1.4 URL(Uniform Resource Location)URL은 인터넷에 존재하는 여러 서버들이 제공하는 자원에 접근할 수 있는 주소를 표현하기 위한것.“프로토콜://호스트명:포트번호/경로명/파이명?쿼리스트링#참조”의 형태로 이루워져있음. 프로토콜 : 자원에 접근하기 위해 서버와 통신하는데 사용되는 통신규약(http) 호스트명: 자원을 제공하는 서버의 이름(www.javahome.com) 포트번호 : 통신에 사용되는 서버의 포트번호(80) 경로명 : 접근하려는 자원이 저장된 서버상의 위치(/sample/) 파일명 : 접근하려는 자원의 이름(hello.html) 쿼리 : url에서 ?이후부분 참조 : url에서 # 이후부분 java에서 URL 클래스를 제공함 1.5 URL Connection어플리케이션과 URL간의 통신연결을 나타내는 클래스의 최상위 추상클래스. 12345678910111213141516171819import java.net.*;import java.io.*;public class NetworkEx3{ public static void main(String[] args){ URL url = null; String address = \"http://www.javahome.com/sample/hello.html\"; String line =\"\"; try{ url = new URL(address); URLConnection conn = url.openConnection(); System.out.println(\"conn.toSTring(): \"+conn); }catch(Exception e){ e.printStackTrace(); } }} 아래코드는 해당 페이지의 내용을 읽어온다.. 123456789101112131415161718192021222324import java.net.*;import java.io.*;public class NetworkEx4{ public static void main(String[] args){ URL url = null; BufferedReader input = null; String address = \"http://www.javahome.com/sample/hello.html\"; String line =\"\"; try{ url = new URL(address); input = new BufferedReader(new InputStreamReader(url.openStream())); while((line= input.readline()) != null) { System.out.println(line); } input.close(); }catch(Exception e){ e.printStackTrace(); } }} 이진파일을 읽어 저장함. 1234567891011121314151617181920212223242526import java.net.*;import java.io.*;public class NetworkEx5{ public static void main(String[] args){ URL url = null; InputStream in = null; FileOutputStream out = null; String address = \"http://www.javahome.com/sample/hello.zip\"; int ch = 0; try{ url = new URL(address); in = url.openStream(); out = new FileOutputStream(\"hello.zip\"); while((ch= inlread()) != -1) { out.writy(ch); } in.close(); out.close(); }catch(Exception e){ e.printStackTrace(); } }} 2. 소켓 프로그래밍소켓을 이용한 통신프로그래밍.java.net패키지를 통해 소켓 프로그래밍을 지원함. 2.1 TCP와 UDPTCP/IP 프로토콜은 이기종 시스템간의 통신을 위한 표준 프로토콜로 프로토콜의 집합이다.TCP와 UDP모두 TCP/IP에 포함되어 있음, OSI 7계층의 전송계층에 해당하는 프로토콜이다. 항목 TCP UDP 연결방식 .연결기반- 연결 후 통신(전화기)- 1:1통신방식 .비연결기반- 연결없이 통신(소포)- 1:1, 1:n, n:n 통신방식 특징 .데이터의 경계를 구분안함.신뢰성 있는 데이터를 전송- 데이터의 전송순서가 보장됨- 데이터의 수신여부를 확인함(데이터가 손실되면 재전송)- 패킷을 관리할 필요가 없음.UDP보다 전송속도가 느림 .데이터의 경계를 구분함.신뢰성 없는 데이터 전송- 데이터의 전송순서가 바뀔 수 있음- 데이터의 수신여부를 확인안 함(데이터가 손실되어도 알 수 없음)- 패킷을 관리해 주어야 함.TCP보다 전송속도가 빠름 관련 클래스 .Scoket.ServerSocket .DatagramSocket.DatagramPacket.MulticastSocket 2.3 TCP 소켓 프로그래밍서버 프로그램과 클라이언트 프로그램간의 통신과정 단계 서버프로그램에서는 서버소켓을 사용하여 서버의 컴퓨터의 특정 포트에서 클라이언트의 연결요청을 처리할 준비를 한다. 클라이언트 프로그램은 접속할 서버의 IP주소와 포트 정보를 가지고 소켓을 생성해서 서버에 연결을 요청한다. 서버소켓은 클라이언트의 연결요청으 ㄹ받으면 서버에서 새로운 소켓을 생성해서 클라이언트의 소켓과 연결되도록 한다. 이제 클라이언트 소켓과 새로 생성된 서버의 소켓은 서버소켓과 관계없이 일대일 통신을 한다. 2.4 UDP 소켓 프로그래밍","link":"/2019/05/10/tec/java/java12/"},{"title":"[CH6. 객체지향프로그래밍1] 오버로딩","text":"4. 메서드 오버로딩4.1 메서드 오버로딩이란?한 클래스 내에 같은 이름의 메서드를 매개변수를 다르게 해서 여러개 정의 하는것. 4.2 오버로딩의 조건 메서드 이름이 같아야 한다. 매개변수의 개수 또는 타입이 달라야 한다. 매개변수는 같고 리턴타입이 다른 경우는 오버로딩이 성립되지 않는다. 4.3 오버로딩의 예12345678910void println();void println(booleand x);void println(char x);void println(char[] x);void println(double x);void println(float x);void println(int x);void println(long x);void println(String x);void println(Object x); 매개 변수의 타입과 개수가 같아서 오버로딩 성립 안하는 예 12int add(int a, int b){ return a+b;}int add(int x, int y){ return x+y;} 리턴 타입만 다른 경우 오버라이딩 성립 안함 12int add(int a, int b){ return a+b;}int add(int a, int b){ return (long) a+b;} 같은 매개변수를 순서만 바꿔서 작성하면 오버로딩이지만 헷갈리는 좋지 않은 방법12int add(int a, long b){ return a+b;}int add(long a, int b){ return a+b;} 4.4 오버로딩의 장점 동일 기능의 메서드가 하나의 이름으로 정의될 수 있음 메서드 이름 절약가능 5. 생성자(Constructor)5.1 생성자란?인스턴스가 생성될 때 호출되는 인스턴스 초기화 메서드 생성자의 이름은 클래스의 이름과 같아야함 생성자는 리턴 값이 없음 new 연산자가 인스턴스를 생성하는것이지, 생성자가 인스턴스를 생성하는것은 아님 5.2 기본 생성자(default constructor)생성자를 안 만들어도 컴파일러가 기본으로 생성자 하나 만들어줌.publid 클래스이름(){}; 1234567891011121314151617181920class Data1{ int value;}class Data2{ int value; Data2(int x){ value = x; }}class ConstructorTest { public stataic void main(String[] args){ Data1 d1 = new Data1(); //컴파일 에러 발생 Data2 d2 = new Data2(); Data2 d2 = new Data2(int 1); }} 5.3 매개변수가 있는 생성자인스턴스 생성할때 초기값을 넣어 초기화 할 수 있음123456789101112class Car{ String color; String gearType; int door; Car(){} Car(String c, String g, int d){ color= c; gearType = g; door =d; }} 이렇게 사용하면 됨1Car c = new Car(\"white\", \"auto\", 4}; 5.4 생성자에서 다른 생성자 호출하기 - this(), this같은 클래스 내에서 생성자도 아래 조건을 만족 할 경우 서로 호출이 가능함 생성자의 이름으로 클래스 이름 대신 this를 사용한다. 한 생성자엥서 다른 생성자를 호출할 때는 반드시 첫줄에서만 호출이 가능하다. 123456789101112131415161718class Car{ String color; String gearType; int door; Car(){ this(\"white\", \"auto\", 4); } Car(String color){ this(color, \"auto\", 4} Car(String color, String gearType, int door){ this.color= color; this.gearType = gearType; this.door =door; }} this - 인스턴스 자신을 가리키느 ㄴ참조변수, 인스턴스의 주소가 저장되어있다.모든 인스턴스 메서드에 지역변수로 숨겨진 채로 존재한다. this.(), this(매개변수) - 생성자, 같은 클래스의 다른 생성자를 호출 할 때 사용한다. 5.5 생성자를 이용한 인스턴스 복사 동일한 현재 상태를 갖는 인트턴스 하나 더 생성할때 생성자를 사용함. 어떤 상태인지 자세히 몰라도 똑같은 인스턴스 새로 추가 가능. 12345Car(Car c){ color= c.color; gearType = c.gearType; door =c.door; } 1234567891011121314151617181920212223class Car{ String color; String gearType; int door; Car(){ this(\"white\", \"auto\", 4); } Car(Car c){ color= c.color; gearType = c.gearType; door =c.door; } Car(String color){ this(color, \"auto\", 4} Car(String color, String gearType, int door){ this.color= color; this.gearType = gearType; this.door =door; }} *** 인스턴스를 생성할 때는 아래 두가지 사항을 결정해야함 클래스 - 어떤 클래스의 인스턴스를 생성할 것인가? 생성자 - 선택한 클래스의 어떤 생성자로 인스턴스를 생성할것인가?","link":"/2019/05/02/tec/java/java3/"},{"title":"[CH7. 객체지향프로그래밍2] 상속","text":"1. 상속1.1 상속의 정의와 장점기존의 클래스를 재사용하여 새로운 클래스를 작성하는것 12class Parent{}class Child extends Parent{} 조상클래스 - 부모클래스, 상위클래스, 기반 클래스 자손클래스 - 자식 클래스, 하위클래스, 파생된 클래스 생성자와 초기화 블럭은 상속되지 않는다. 멤버만 상속된다. 자손 클래스의 멤버개수는 조상 클래스보다 항상 같거나 많다. 1234567891011121314151617class Tv{ boolean power; int channel; void power(){power = !power;} void channelUp(){++chnannel;} void channelDown(){--channel;}}class CaptionTv extends Tv{ boolean caption; void displayCaption(String text){ if(caption){ system.out.println(text); } }} 1.2 클래스간의 관계 - 포함관계12345class Circle{ int x; int y; int r;} 이 클래스를 123456789class Point{ int x; int y;}class Circle{ Point point = new Point(); int r;} 이렇게 표현할 수 있다.Engine, Door 클래스를 미리 작성 후 아래와 같이 사용 가능. 1234class car{ Engine e = new Engine(); Door[] d = new Door[4];} 1.3 클래스간 관계 결정하기어떨때 상속, 어떨때 포함관계를 맺을까? 상속: ~은 ~이다(is-a) 포함 : ~은 ~을 가지고 있다(has-a) ex) 원은 점(point)이다 (X) 원은 점을 가지고 있다(O) -&gt; 포함관계 SportCar는 Car이다(0) -&gt; 상속 관계 1.4 단일 상속부모클래스를 두개 이상 상속 받을 수 없다. 1234//불가능한 경우calss TVCR extends TV, VCR{} 1234567891011121314151617181920212223242526272829303132333435class Tv{ boolean power; int channel; void power(){power = !power;} void channelUp(){++chnannel;} void channelDown(){--channel;}}class VCR{ boolean power; int counter =0; void power(){}; void play(){}; void stop(){}; void rew(){}; void ff(){};}class TVCR extends Tv{ VCR vcr = new VCR(); int counter =vcr.counter; void play(){ vcr.play(); }; void stop(){ vcr.stop(); }; void rew(){ vcr.rew(); }; void ff(){ vcr.ff(); }; 1.5 Object클래스 -모든 클래스의 조상Object는 모든 클래스의 조상이다. 1class Tv{} 이것은 따지고 보면 1class Tv extends Object{} 이것임.toString(), equals() 그냥 쓸 수 있는게 Object클래스에 정의 되어있어서 그렇다.","link":"/2019/05/03/tec/java/java5/"},{"title":"[CH11. 컬렉션프레임웍과 유용한 클래스] 컬렉션 프레임워크","text":"1. 컬렉션 프레임웍(Collection Framework)1.6 Enumeration, Iterator, ListIterator1.6.1 Iterator컬렉션에 저장된 각 요소에 접근하는 기능을 가진 Iterator인터페이스를 정의해 Collection인터페이스에 Iterator를 반환하는 iterator()를 정의하고있다. 12345678910public interface Iterator{ boolean hasNext(); ObjectNext(); void remove();}public interface Collection { public Iterator();} iterator()은 Collection 인터페이스에 구현되어있기 때문에 자손 클래스인 List와 Set에도 포함되어 있음. 메서드 설명 boolean hasNext() 읽어올 요소가 남아있는지 확인. 있으면 true, 없으면 false를 반환한다. Object next() 다음 요소를 읽어온다. next()를 호출하기 전에 hasNext()를 호출해 확인하는것이 안전하다. void remove() next()로 읽어 온 요소를 삭제. next()호출 한 다음에 remove()를 호출해야 한다. 1.6.2 Enumeration과 ListIterator Enumeration은 컬렉션 프레임웍이 만들어지기 전에 사용하는것 Iterator의 구버전. Iterator를 사용하자. ListIterator는 Iterator를 상속받아 기능을 추가한 것. 양방향으로 이동이 가능함.ArrayList나 LinkedList와 같이 List인터페이스를 구현한 컬렉션에서만 사용가능 1.7 HashSetHashSet은 Set인터페이스를 구현한 가장 대표적 컬렉션.중복된 요소를 저장하지 않음. 저장순서를 유지하지 않음.저장순서 유지하려면 LinkedHashSet을 사용하면 됨. 생성자 또는 메서드 설명 HashSet() HashSet객체를 생성한다. HashSet(Collection c) 주어진 컬렉션을 포함하는 HashSet객체를 생성한다. HashSet(int initialCapactiy) 주어진 값을 초기용량으로 하는 HashSet객체를 생성한다. HashSet(int initialCapactiy, float loadFactor) 초기용량과 load factor를 지정하는 생성자 boolean add(Object o) 새로운 객체를 저장한다 boolean addAll(Collection c) 주어진 컬렉션에 모든 객체를 추가한다. void clear() 저장된 모든 객체를 삭제한다. Object clone() HashSEt을 복제하여 반환한다. boolean contains(Object o) 지정된 객체를 포함하고 있는지 알려준다. boolean containsAll(Collection c) 주어진 컬렉션에 저장된 모든 객체들을 포함하고 있는지 알려준다. boolean isEmpty() HashSet이 비어있는지 알려준다. boolean iterator() Iterator 를 반환한다. boolean remove(Object o) 지정된 객체를 HashSet에서 삭제한다. boolean removeAll(Collection c) 주어진컬렉션에 저장된 모든 객체와 동일한 것을 HashSet에서 모두 삭제한다(차집합) boolean retainAll(Collection c) 주어진 컬렉션에 저장된 객체와 동일한 것만 남기고 삭제한다.(교집합) int size() 저장된 객체의 개수를 반환한다. Object[] toArray() 저장된 객체들을 객체배열의 형태로 변환한다. Object[] toArray(Object[] a) 저장된 객체들을 주어진 객체배열 a에 담는다. 1.8 ThreeSetThreeSet은 이진검색트리라는 자료구조의 형태로 데이터를 저장하는 컬렉션 클래스.정렬, 검색, 범위검색에 뛰어난 성능을 보인다.","link":"/2019/05/11/tec/java/java14/"},{"title":"[CH6. 객체지향프로그래밍1 ] 변수의 초기화","text":"6. 변수의 초기화6.1 변수의 초기화변수를 선언하고 처읍으로 값을 저장하는것.가능하면 선언과 동시에 초기화 하는게 바람직. 멤버변수(클래스변수와 인스턴스 변수)와 배열의 초기화는 선택적이지만,지역변수는 반드시 초기화 후 사용해야함. 멤버변수 추기화 방법 명시적 초기화 생성자 초기화 블럭 인스턴스 초기화 블럭: 인스턴스변수를 초기화 하는데 사용 클래스 초기화 블럭: 클래스를 초기화 하는데 사용 6.2 명시적 초기화 변수 선언과 동시에 초기화 하는것 1234class Car{ int door= 4; //기본형 변수 초기화 Engine = new Engine(); // 참조형 변수 초기화} 6. 3 초기화 블럭 초기화 블럭 - 클래스변수의 복잡한 초기화에 사용 인스턴스 초기화 블럭 - 인스턴스 변수의 복잡한 초기화에 사용 1234class InitBlock{ static{/* 클래스 초기화 블럭*/} {/*인스턴스 초기화 블럭 */}} 클래스 초기화 블럭은 클래스가 메모리에 올라가 갈 때 한번만 수행.인스턴스 초기화는 인스턴스 생성될때 생성자보다 먼저 수행됨. 12345678910Car(){ System.out.println(\"Car인스턴스가 생성되었습니다.\"); color= \"withe\"; gearType=\"auto\";}Car(String color, String gearType){ System.out.println(\"Car인스턴스가 생성되었습니다.\"); this.color= color; this.gearType=gearType;} 동일한 “Car인스턴스가 생성되었습니다.” 처리를 인스턴스 블럭으로 아래와 같이 처리 12345678910{ System.out.println(\"Car인스턴스가 생성되었습니다.\"); }Car(){ color= \"withe\"; gearType=\"auto\";}Car(String color, String gearType){ this.color= color; this.gearType=gearType;} 6.4 멤버변수의 초기화 시기와 순서 클래스 변수 초기화 시점 - 클래스가 처음 로딩될 때 한번 초기화 인스턴스 변수의 초기화 시점 - 인스턴스가 생성될 때마다 각 인스턴스별로 초기화 이루어짐 클래스 변수 초기화 순서 : 기본값 -&gt; 명시적 초기화 -&gt; 클래스 초기화 블럭 인스턴스 변수 초기화 순서 : 기본값 -&gt; 명시적 초기화 -&gt; 인스턴스초기화 블럭 -&gt; 생성자 1234567891011class Product{ static int count =0; //생성된 인스턴스 수를 저장하기 위한 변수 int serialNo; //인스턴스 고유 번호 { ++count; serialNo = count; // Product인스턴스가 생성될 때마다 count 값을 1증가시켜 serialNo에 저장 } public product(){}}","link":"/2019/05/03/tec/java/java4/"},{"title":"[CH7. 객체지향프로그래밍2] 추상클래스","text":"6. 추상클래스6.1 추상클래스란?미완성된 설계도. 미완성 메서드(추상메서드)를 포함하고 있는 클래스.추상 클래스는 상속을 통해 자손클래스에 의해서만 완성될 수 있음.123abstract class 클래스이름{ } 6.2 추상메서드메서드 선언부와 구현부 중 선언부만 작성한것.1abstract 리턴타입 메서드이름(); 123456789101112131415161718abstract class Player{ abstract void play(int pos); abstract void stop();}class AudioPlayeer extends Player{ void play(int pos){ // 기능 구현 } void stop(){ //기능 구현 } }abstract class AbstractPlayer extends Player{ void play(int pos) { // 기능 구현 }} 6.3 추상클래스의 작성 추상 : 낱낱의 구체적 표상이나 개념에서 공통된 성질을 뽑아 이를 일반적인 개념으로 파악하는 정신 작용. 추상화 : 클래스간의 공통점을 찾아내서 공통의 조상을 만드는 작업. 구체화 : 상속을 통해 클래스를 구현, 확장하는 작업 123456789101112131415161718192021222324abstract class Player{ boolean pause; int currentPos; Player(){ pause = false; currentPos = 0; } abstract void play(int pos); abstract void stop(); void play(){ play(currentPos); } void pause (){ if(pause){ pause = false; }else { pause = true; stop(); } }} 위의 Player추상클래스를 조상으로 하는 CDPlayer12345678910111213141516171819class CDPlayer extends player{ void play(int currentPos){ //기능 구현 } void stop(){ //기능 구현 } int currentTrace; void nextTrace(){ currentTrace++; } void preTrace(){ if(currentTrace&gt;1){ currentTrace--; } }} 추상메서드로 안 만들고 구현부를 빈 상태로 두어 자손 클래스에서 오버라이드해서 사용할 수 있지만추상메서드로하면 필수로 구연해야 한다. 12345678910111213141516171819class Marine{ int x,y; void move(int x, int y){} void stop(){}; void stimPack(){}}class Tank{ int x,y; void move(int x, int y){} void stop(){}; void changeMode(){}}class Dropship{ int x,y; void move(int x, int y){} void stop(){}; void load(){} void unload(){} } 위에서 공통부분을 뽑아내서 추상클래스 Unit을 만들어 다시 구현.123456789101112131415161718abstract class Unit{ int x,y; abstract void move(int x, int y); void stop(){};}class Marine extends Unit{ void move(int x, int y){} void stimPack(){}}class Tank extends Unit{ void move(int x, int y){} void changeMode(){}}class Dropship extends Unit{ void move(int x, int y){} void load(){} void unload(){} } 위와같이 구현하면 아래처럼 Unit으로 배열로 다룰 수 있음12345Unit[] grop = new Unit[4];group[0] = new Marine();group[1] = new Tank();group[2] = new Marine();group[4] = new Dropship();","link":"/2019/05/07/tec/java/java9/"},{"title":"[공유기 도메인 설정] LG U+ 공유기로 무료 도메인 설정하기","text":"1. LG U+ 라우터 접속 http://192.168.219.1 에 접속한다.(윈도우+cmd창에서 ipconfig 하면 기본 게이트 웨이 주소) 2.공유기에 적힌 ‘웹admin암호’로 로그인한다. 3. DDNS 설정부분의 톱니바퀴 모양을 누른다. 4. 네트워크 설정 - 세부설정 - DDNS 버튼을 눌러도 됨.DDNS 설정을 사용함으로 바꾼다.DDNS 서버를 noip.com 을 선택하고 DDNS사용자 등록을 누른다. 5. noip.com 에 가서 sign up 버튼을 눌러 회원가입을 한다.noip 홈페이지 6. email, 비밀번호, 호스트네임을 넣고 원하는 도메인주소를 선택한다.free sign up 버튼을 누른다. 7. 여기에서 프로그램을 다운받아 실행한다. 8. 다운로드 받은 프로그램을 실행해서 로그인 한다. 9. 만든 도메인을 클릭하고 save버튼을 누른다. 10. 공유기 라우터 화면으로 돌아와서 사용자, 비밀번호, 호스트 도메인 이름을 넣고 설정 적용 버튼을 누른다. 11. host도메인에 접속하여 잘 접속되는지 확인한다.","link":"/2019/06/17/tec/network/network1/"},{"title":"[CH7. 객체지향프로그래밍2] 오버라이딩","text":"2. 오버라이딩2.1 오버라이딩이란?조상 클래스부터 상속받은 메서드의 내용을 변경하는것12345678910111213141516class Point{ int x; int y; String getLocation(){ return \"x : \"+x+\", y : \" + y; }|class Point3D extends Point{ int z; String getLocation(){ return \"x : \"+x+\", y : \" + y+\", z : \"+z; }} 2.2 오버라이딩의 조건메서드 선언부는 조상의 것과 완전 일치해야함.자손 클래스에서 오버라이딩하는 메서드는 조상 클래스의 메서드와 이름이 같아야 한다. 매개변수가 같아야 한다. 리턴 타입이 같아야 한다. 접근제어자는 조상 클래스의 메서드보다 좁은 범위로 변경할 수 없다.ex) 조상클래스의 메서드의 접근 제어자가 protected라면자식클래스에서 오버라이딩 하는 메서드의 접근 제어자는 protected나 public 이어야함. 조상 클래스의 메서드보다 많은 수의 예외를 선언할 수 없다. 조상 클래스의 메서드를 자손클래스에서 오버라이딩할 때 접근제어자를 조상클래스의 메서드보다 좁은 범위로 할 수 없다. 예외는 조상 클래스의 메서드보다 많이 선언할 수 없다. 인스턴스메서드를 static메서드로 또는 그 반대로 변경할 수 없다. 2.3 오버로딩 VS 오버라이딩 오버로딩(overloading) : 기존에 없는 메서드를 정의하는것(new) 오버라이딩(overriding) : 상속받은 메서드의 내용을 변경하는 것(change, modify) 123456789101112class Parent{ void parentMethod(){};}class Chile extends Parent{ void parentMethod(){} // 오버라이딩; void parentMethod(int i){} //오버로딩 void childMethod(){} void childMethod(int i){} //오버로딩 void childMethod(){}// 에러 함수가 중복됨} 2.4 super자손클래스에서 조상 클래스로부터 상속받은 멤버를 참조하는데 사용되는 참조변수.조상클래스의 멤버와 자손클래스의 멤버가 중복 정의되서 구별해야 되지 않는 상황이면 super대신 this를 써도 됨.static 메서드(클래스 메서드)에서는 사용 할 수 없다. 12345678910111213141516171819class SuperTest{ public void static void main(String args[]){ Child c = new Child(); c.method(); }}class Parent{ int x =10;}class Child extends Parent{ int x =20; void method(){ system.out.println(\"x=\"+x); system.out.println(\"this.x=\"+this.x); system.out.println(\"super.x=\"+super.x); }} 실행 결과123x=20this.x=20;super.x=10; 2.5 super() - 조상클래스의 생성자super()는 조상클래스의 생성자를 호출하는 생성자이다.Object클래스를 제외한 모든 클래스의 생성자 첫 줄에는 생성자(같은 클래스의 다른 생성자 또는 조상의 생성자)를 호출 해야함.그렇지 않으면 컴파일러가 super(); 를 자동으로 첫줄에 삽입. 클래스 - 어떤 클래스의 인스턴스를 생성할것인가? 생성자 - 선택한 클래스의 어떤 생성자를 이용해서 인스턴스를 생성할 것인가?","link":"/2019/05/04/tec/java/java6/"},{"title":"[CH7. 객체지향프로그래밍2] Package와 import","text":"3 Package와 import3.1 패키지(package)패키지란, 클래스의 묶음. 물리적으로 하나의 디렉터리임.ex) java.lang.String은 java/lang 디렉터리에 위치한 Strig 클래스이다. 하나의 소스파일에는 첫번째 문장으로 단 한번의 패키지 선언만을 허용한다. 모든 클래스는 반드시 하나의 패키지에 속해야 된다. 패키지는 점(.)을 구분자로 하여 계층구조로 구성할 수 있다. 패키지는 물리적으로 클래스 파일(.class)을 포함하는 하나의 디렉터리다. 3.2 패키지의 선언1package 패키지명; 3.3 import 문import 문은 컴파일러에게 소스파일에 사용된 클래스의 패키지에 대한 정보를 제공함. 3.4 import문의 선언일반적인 소스 파일(*.java)의 구성은 다음의 순서로 되어있다. package문 import문 클래스선언 12import 패키지명.클래스명;import 패키지명.*; 4 제어자4.1 제어자란?클래스, 변수 또는 메서드의 선언부에 함께 사용되어 부가적인 의미를 부여함 접근제어자 - public, protected, default, private 그외 - static, final, abstract, native, transient, synchronized, volatile, strictfp제어자는 클래스, 멤버변수, 메서드에 주로 사용됨.하나의 대상에 여러 제어자를 조합하는 것은 가능하나 접근제어자는 하나만 쓸 수 있다. 4.2 static - 클래스의, 공통적인 static 이 사용될 수 있는곳 : 멤머변수, 메서드, 초기화 블럭 *static 대상 의미 멤버변수 - 모든 인스턴스에 공통적으로 사용되는 클래스 변수가 된다. - 클래스변수는 인스턴스를 생성하지 않고도 가능하다. - 클래스가 메모리에 로드될 때 생성된다. 메서드 - 인스턴스를 생성하지 않고도 호룰이 가능한 static 메서드가 된다. static 메서드 내에선 인스턴스 멤버들을 직접 사용할 수 없다. 123456789101112class StaticTest{ static int width =200; static int height = 120; static { // static 변수의 초기화 수행 } static int max(int a, int b){ return a&gt;b?a:b; }} 4.3 final - 마지막의, 변경될 수 없는final이 사용될 수 있는 곳 - 클래스, 메서드, 멤버변수, 지역변수*final 대상 의미 클래스 변경될 수 없는 클래스, 확장될 수 없는 클래스가 된다. 그래서 final로 지정된 클래스는 다른 클래스의 조상이 될 수 없음 메서드 변경될 수 없는 메서드, final로 지정된 메서드는 오버라이딩을 통해 재정의 될 수 없다. 멤버변수/지역변수 변수 앞에 final이 붙으면 값을 변경할 수 없는 상수가 된다. 12345678final class FinalTest{ final int MAX_SIZE = 10; final void getMaxSize(){ final int LV = MAX_SIZE; return MAX_SIZE; }} 4.4 생성자를 이용한 final 멤버변수 초기화final 붙은 변수는 상수임으로 일반적으로 선언과 초기화를 동시에 하지만, 인스턴스 변수의 경우 생성자에서 초기화 되도록 할 수 있다.각 인스턴스마다 final 이 붙은 멤버 변수가 다른 값을 갖도록 하는 것이 가능하다.123456789101112131415class Card{ final int NUMBER; final String KIND; static int width = 100; static int height =250; Card(String kind, int num){ KIND = kind; NUMBER = num; } Card(){ this(\"HEART\",1); }} 4.5 abstract - 추상의, 미완성의미완성의 의미를 가지고 있다.메서드의 선언부만 작성하고 실제 수행내용은 구현하지 않은 추상 메서드를 선언하는데 사용함. abstract가 사용될 수 있는 곳 - 클래스, 메서드 *abstract 대상 의미 클래스 클래스 내에 추상메서드가 선언되어 있음을 의미한다. 메서드 선언부만 작성하고 구현부는 작성하지 않은 추상메서드임을 알린다. 123abstract class AbstractTest{ abstract void move();} 4.6 접근제어자 멤버 또는 클래스에 사용되어 외부에서 접근하지 못하게 제한하는 역할. 접근 제어자가 사용될 수 있는곳- 클래스, 멤버변수, 메서드, 생성자 private : 같은 클래스 내에서만 접근이 가능하다. default : 같은 패키지 내에서만 접근이 가은하다. protected : 같은 패키지 내에서, 그리고 다른 패키지의 자손 클래스에서 접근이 가능하다. public : 접근 제한이 없다. 4.7 접근 제어자를 이용한 캡슐화접근 제어자 사용하는 이유: 외부로 부터 데이터를 보호하기 위해 외부에는 불필요한 내부적으로만 사용되는 부분을 감추기 위해 123456789101112131415161718192021222324252627public class Time{ private int hour; private int minute; private int second; public int getHour(){return hour;} public void setHour(int hour){ if(hour&lt;0 || hour &gt; 23){ return; } this.hour = hour; } public int getMinute(){return minute;} public void setMinute(int min){ if(min&lt;0 || hour &gt; 59){ return; } this.minute = min; } public int getSecond(){return second;} public void setSecond(int sec){ if(sec &lt;0 || sec &gt; 59){ return; } this.second = sec; }} 4.9 제어자의 조합 대상 사용가능한 제어자 클래스 public, default, final, abstract 메서드 모든 접근제어자, final, abstract, static 멤버변수 모든 접근제어자, final, static 지역변수 final 메서드에 static과 abstract를 함께 사용할 수 없다. 클래스에 abstract와 final을 동시에 사용할 수 없다. abstract메서드의 접근제어자가 private일 수 없다. 메서드에 private와 final을 같이 사용할 필요는 없다.(둘중 하나만 사용해도 충분)","link":"/2019/05/05/tec/java/java7/"},{"title":"[CH7. 객체지향프로그래밍2] 다형성","text":"5. 다형성5.1 다형성이란?여러가지 형태를 가질 수 있는 능력.조상클래스 타입의 참조변수로 자손클래스의 인스턴스를 참조할 수 있도록 함.12345678910111213class Tv{ boolean power; int channel; void power(){power = !power;} void channelUp(){++channel;} void channelDown(){--channel;}}class CaptionTv extends Tv{ String text; void caption(){};} 12Tv t = new Tv();CaptionTv c = new CaptionTv(); 1Tv t = new CaptionTv(); 12CaptionTv c = new CaptionTv();Tv t = new CaptionTv(); 12//이렇게는 불가능함CaptionTv c = new Tv(); 조상 타입의 참조변수로 자손타입의 인스턴스를 참조할 수 있다.반대로 자손타입의 참조변수로 조상타입의 인스턴스를 참조할 수는 없다. 5.2 참조변수의 형병환자손타입-&gt;조상타입(up-castion) : 형변환 생략 가능자손타입&lt;-조상타입(Down-castion) : 형변환 생략 불가 12345678910111213141516171819202122class Car{ String color; int door; void drive(){ System.out.println(\"drive, Brrr~\"); } void stop(){ System.out.println(\"stop!!\"); } }class FireEngine extends Car{ void water(){ System.out.println(\"water!!!\"); }}class Ambulance extends Car { void siren(){ System.out.println(\"siren~~!\"); }} FireEngine타입과 Ambulance타입은 서로 형변환 불가능Car 타입과 FireEngine 타입 형변환 예시123456Car car = null;FireEngine fe = new FireEngine();FireEngine fe2 = null;car = fe; //car = (Car) fe; 형변환이 생략된 형태fe2 = (FireEngine) car; //형변환 생략 불가. 아래 예제는 컴파일에러는 발생하지 않지만 실행시 에러가 발생함.12345678910111213141516171819202122232425262728293031323334class CastingTest2{ public static void main(String args[]){ Car car = new Car(); Car car2 = null; FireEngine fe = null; car.drive(); fe = (FireEngine) car; //실행시 여기서 에러 발생 fe.drive(); car2 = fe; car2.drive(); } }``` car가 Car타입의 인스턴스여서 FireEngine을 받을 수 없음.- 캐스트연산자를 사용하면 서로 상속관계에 있는 클래스 타입의 참조변수간의 형변환은 양방향으로 자유롭게 수행될 수 있다. 그러나 참조변수가 참조하고 있는 인스턴스의 자손타입으로 형변환을 하는것은 허용되지 않는다. ### 5.3 instanceof연산자 참조변수가 참조하는 인스턴스 실제타입을 확인하기 위해 instanceof연산자 사용. 주로 조건문에사용. * 값이 ull인 참조변수에 대해 instanceof연산을 하면 false나옴. ```javavoid doWork(Car c){ if(c instanceof FireEngine){ FireEngine fe = (FireEngind) c; fe.water(); } else if( c instance of Ambulance){ Ambulance a = (Ambulance) c; a.siren(); }} 123456789101112131415class InstanceOfTest{ public static void main (String args[]){ FireEngine fe = new FireEngine(); if(fe instanceof FireEngine){ System.out.println(\"FireEngine instance\"); } if( fe instanceof Car){ System.out.println(\"Car instance\"); } if( fe instanceof Object){ System.out.println(\"Object instance\"); } }} 위의 코드를 실행할 경우123FireEngine instanceCar instanceObject instance 5.4 참조변수와 인스턴스의 연결멤버변수가 조상클래스와 자손클래스에 중복으로 정의된 경우, 조상 타입의 참조변수를 사용했을 때는 조상클래스에 선언된 멤버변수가 사용되고, 지손타입의 참조변수를 사용했을 때는 자손틀래스에 선언된 멤버변수가 사용된다. 123456789101112131415161718192021222324252627class BindingTest{ public static void main(String[] args){ Parent p = new Child(); Child c = new Child(); System.out.println(\"p.x =\" + p.x); p.method(); System.out.println(\"c.x= \"+c.x); c.method(); }}class Parent { int x = 100; void method(){ System.out.println(\"Parent Method\"); }}class Child{ int x = 200; void method(){ System.out.println(\"Child Method\"); }} 실행결과1234p.x=100Child Methodc.x=200Child Method 5.5 매개변수의 다형성5.6 여러 종류의 객체를 하나의 배열로 다루기","link":"/2019/05/06/tec/java/java8/"},{"title":"[React 교과서] 5장 React 컴포넌트 라이프사이클 이벤트","text":"리엑트 교과서를 정리한 내용입니다. 5.1 React컴포넌트 라이프사이클 이벤트 한눈에 살펴보기라이프사이클 이벤트를 기반으로 컴포넌트의 동작을 제어하고 사용자 정의를 할 수 있다. 마운팅 이벤트 : React엘리먼트를 DOM 노드에 추가할때 발생 갱신 이벤트 : 속성이나 상태가 변경되어 React엘리먼트를 갱신할 때 발생 언마운팅이벤트 : React엘리먼트를 DOM에서 제거할때 발생 5.2 이벤트 분류 마운팅 : React가 이벤트를 한번만 실행 갱신: React가 이벤트를 여러번 실행 언마운팅: React가 이벤트를 한번만 실행 아래 순서로 라이플 사이클이 실행된다 constructor() : 엘리먼트를 생성하여 기본속성과 상태를 설정할때 실행 마운팅 componentWillMount(): DOM에 삽입전에 실행 componentDidMount(): DOM에 삽입 후에 실행 갱신 componentWillRecetiveProps(nextProps) : 컴포넌트가 속성을 받기 직전에 실행 shouldComponentUpdate(nextProps, nextState) : 컴포넌트가 갱신되는 조건을 정의해서 재렌더링을 초적화함. boolean값을 반환 componentWillUpdate(nextProps, nextState) : 컴포넌트가 갱신되기 직전에 실행 componentDidUpdate(prevProps, prevState) : 컴포넌트가 갱신된 후에 실행 언마운팅 componentWillUnmount() : 컴포넌트를 DOM에서 제거하기 전에 실행, 구독한 이벤트를 제거하거나 다른 정리 작업 수행 가능 라이플사이클 이벤트와 속성 및 상태의 상관관계 마운팅 컴포넌트 속성 갱신 컴포넌트 상태 갱신 constructor() componentWillMount() componentWillRecetiveProps() shouldComponentUpdate() shouldComponentUpdate() componentWillUpdate() componentWillUpdate() render() render() render() componentDidUpdate() componentDidUpdate() componentDidMount() forceUpdate()를 이용한 갱신 언마운팅 componentWillUpdate() render() componentDidUpdate() componentWillUnmount() 5.3 이벤트 구현라이프사이클 이벤트를 구현하려면 클래스에 메서드를 정의해야함.ex) componentDidMouht()를 정의하면 컴포넌트 클래스의 엘리먼트가 DOM에 추가되었을때 이 메서드 호출하고 마운팅으로 분류 되어있으므로 컴포넌트 클래스의 인스턴스마다 한번만 호출됨. 123456789101112class Content extends React.Component { componentWillMount(){ console.log(ReactDOM.findDOMNode(this)) // DOM 노드가 null } componentDidMount(){ console.dir(ReactDOM.findDOMNode(this)) // DOM 노드가 &lt;div&gt; } render(){ return() }} DOM은 늘 대문자로 쓴다. 5.4 모든 이벤트 실행하기 Logger컴포넌트의 렌더링과 세번의 갱신 실행 코드12345678910111213141516171819202122class Content extends React.Component { constructor(props) { super(props) this.launchClock() this.state = { counter: 0, currentTime: (new Date()).toLocaleString() } } launchClock() { setInterval(()=&gt;{ this.setState({ counter: ++this.state.counter, currentTime: (new Date()).toLocaleString() }) }, 1000) } render() { if (this.state.counter &gt; 2) return &lt;div/&gt; return &lt;Logger time={this.state.currentTime}&gt;&lt;/Logger&gt; }} 123456789101112131415161718192021222324252627282930313233343536373839404142class Logger extends React.Component { constructor(props) { super(props) console.log('constructor') } componentWillMount() { console.log('componentWillMount is triggered') } componentDidMount(e) { console.log('componentDidMount is triggered') console.log('DOM node: ', ReactDOM.findDOMNode(this)) } componentWillReceiveProps(newProps) { console.log('componentWillReceiveProps is triggered') console.log('new props: ', newProps) } shouldComponentUpdate(newProps, newState) { console.log('shouldComponentUpdate is triggered') console.log('new props: ', newProps) console.log('new state: ', newState) return true } componentWillUpdate(newProps, newState) { console.log('componentWillUpdate is triggered') console.log('new props: ', newProps) console.log('new state: ', newState) } componentDidUpdate(oldProps, oldState) { console.log('componentDidUpdate is triggered') console.log('old props: ', oldProps) console.log('old state: ', oldState) } componentWillUnmount() { console.log('componentWillUnmount') } render() { console.log('rendering... Display') return ( &lt;div&gt;{this.props.time}&lt;/div&gt; ) }} 5.5 마운팅 이벤트마운팅 이벤트 유형은 실제 DOM에 컴포넌트를 추가하는 것에 대한 이벤트다. componentWillMount(): React엘리먼트가 실제 DOM에 곧 추가 될 것을 알림 componentDidMount(): React엘리먼트를 실제 DOM에 추가한 시전으로, 이 시점의 React엘리먼트는 DOM노드임.*constructor()는 componentWillMount()보다 먼저 실행됨. 5.5.1 componentWillMount()초기 렌더링 직전에 실행됨. 브라우저와 프론트엔드에서 이루어짐.서버 렌더링 과정에서도 componentWillMount()는 실행됨. 5.5.2 componentDidMount()초기렌더링 마친 후 실행됨. 브라우저에서 한번 실행되고 서버렌더링에서는 실행 안 됨.자식엘리먼트를 참조로 접근할 수 있음. 자식 컴포넌트의 componentDidMount()는 부모 컴포넌트의 componentDidMount()보다 먼저 호출됨 componentDidMount() 이벤트는 다른 라이브러리를 통합하기 가장 적절한 위치임. 123456789101112131415161718192021222324252627class Users extends React.Component { constructor(props) { super(props) this.state = { users: [] // 이렇게 초기화 해놔야 render()에서 해당 상태가 존재하는지 안 하는지 신경 안쓸 수 있음 } } componentDidMount() { fetch(this.props['data-url']) .then((response)=&gt;response.json()) .then((users)=&gt;this.setState({users: users})) } render() { return &lt;div className=\"container\"&gt; &lt;h1&gt;List of Users&lt;/h1&gt; &lt;table className=\"table-striped table-condensed table table-bordered table-hover\"&gt; &lt;tbody&gt;{this.state.users.map((user)=&gt; &lt;tr key={user.id}&gt; &lt;td&gt;{user.first_name} {user.last_name}&lt;/td&gt; &lt;td&gt; {user.email}&lt;/td&gt; &lt;td&gt; {user.ip_address}&lt;/td&gt; &lt;/tr&gt;)} &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; }} XHR 요청을 위한 코드를 componentDidMount()에 사용하는 것이 좋음 5.6 갱신 이벤트마운팅 이벤트는 React를 다른 프레임워크나 라이브러리 데이터 저장소와 연결하는데 사용하곤 함.갱신 이벤트는 컴포넌트를 갱신하는것과 관련됨. componentWillRecivierProps(newProps) shouldComponentUpdate() componentWillIpdate() componentDidUpdate() 5.7 언마운팅 이벤트DOM에서 요소를 분리하거나 제거하는것 5.7.1 componentWillUnmount()DOM에서 컴포넌트가 제거되기 직전 호출.ex)타이머 제거하거나 DOM요소 정리하거나, componentDidMount()에서 연결한 이벤트 제거 등.","link":"/2019/08/29/tec/react/react6/"},{"title":"[React 교과서] 1장 React 살펴보기","text":"리엑트 교과서를 정리한 내용입니다. 1.1 React란 무엇인가? 페이스북에서 만든 자바스크립트 기반의 UI 컴포넌트 라이브러리. 1.2 React가 해결할 수 있는 문제 DOM을 매번 새로 생성하기 위해 UI를 함수로 만들었다. 1.3 React의 장점 단순한 앱 개발 빠른 UI 코드량 감소 1.3.1 간결성 선언형 스타일 채택 순수한 자바스크립트를 이용한 컴포넌트 기반 아키텍쳐 강력한 추상화 선언형 스타일 채택선언형 스타일의 장점은 간단하고 가독성이 좋다. 결과값에 더 집중했다.뷰에 변경이 발생하는경우 react가 알아서 갱신. 명령형 코드 예시123456var arr =[1,2,3,4,5],arr2 = []for (var i=0; i&lt;arr.length; i++){ arr2[i] = arr[i]*2}console.log('a',arr2) 결과창1a [2,4,6,8,10] 선언형 코드 예시123var arr = [1,2,3,4,5]arr2 = arr.map(function(v,i){ return v*2 })console.log('b', arr2) 결과창1b [2,4,6,8,10] 자바스크립트를 이용한 컴포넌트 기반 아키텍처코드 재사용이 쉬워 코드를 줄일 수 있다. 코드 예시12if (user.session) return React.createElement('a',{hret: '/logout'}, 'Logout')else return React.createElement('a', {href:'/login'}, 'Login') 강력한 추상화내부 인터페이스를 숨기고 정규화 과정을 거친 합성 메서드와 속성을 제공한다. 1.3.2 속도와 테스트 용이성가상 DOM은 자바스크립트 메모리에만 존자한다. 데이터 변경시 가상 DOM을 머저 비교하고 랜더링이 필요한 경우애만 실제 DDM에 랜더링 한다.필요한 부분반 갱신함. 1.3.3 React의 폭넓은 개발 커뮤니티와 생태계 React 컴포넌트 목록: 1[2](http://devarchy.com/react-components) 등등.. 1.4 React의 단점 AngularJS나 Ember같은 기능을 사용하려면 라이브러리를 함꼐 사용해야함 다른 프레임워크만큼 성숙하지 않음.-&gt; 핵심 API가 조금씩 바뀜 관련 자료가 부족 단방향 데이터 바인딩만 제공 리액티브 프로그래밍은 아니다. 1.5 웹 애플리케이션에 React적용하기 UI 라이브러리로 React와 관련된 Reduz나 React Router를 활용한 단일 페이지 애플리케이션 스택의 구성 MVC의 V를 대체하는 UI라이브러리로 기존 IVX프레임워크와 결합 jQuery 를 기반으로 서버 측 렌더링을 거친 애플리케이션에서 자동완성 등 일부 기능을 위한 UI컴포넌트로 활용 대부분의 로직을 직접처리하는 백엔드에서 서버측 렌더링 탬플릿 라이브러리로 활용 백엔드와 프론트엔드서 모두 자바스크립트를 사용하는 경우 React Native를 UI 라이브러리로 사용한 모바일 앱 여러가지 렌더링 대상에 적용할 목적으로 사용하는 UI라이브러리 1.5.1 React 라이브러리와 렌더링 대상 UI개발이 필요한 환경에 어디든지 사용할 수 있게 만드는중. ReactDOM.rander()를 사용함(여러 환경에서 사용가능) 1.5.2 단일 페이지 애플리케이션과 React서버보다는 클라이언트(브라우저)에 로직이 더 많은 팻 클라이언트다. SPA는 HTML렌더링, 입력값 겁증, UI변경 등의 기능을 브라우저에서 해결한다.SPA 방식으로는 MVC아키텍처를 많이 사용하지만 다른 방식도 있음. 1.5.3 React 개발 스택모델링,스타일라우팅 등에 정해진 방법이 없어 다른 라이브러리를 결합해 사용한다. (책 56쪽) 데이터 모젤링과 백엔드 라우팅 React용 Bootstrap컴포넌트 날짜 입력 컴포넌트 WAI-ARIA정의를 따르는 자동완성컴포넌트 1.6 첫번째 React앱 만들기:Hello World파일구조/hello-world /js react.js react-dom.js index.html 예시 코드는 여기 에서 다운받을 수 있다. index.html파일 내용123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;script src=\"js/react.js\"&gt;&lt;/script&gt; &lt;script src=\"js/react-dom.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"content\"&gt;&lt;/div&gt; &lt;script type=\"text/javascript\"&gt; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; React 엘리먼트를 생성하려면 React.createElement(clementName, data, child)를 호출한다 elementName : HTML 태그명’h1’처럼 문자열로 작성하거나 직접 만든 컴포넌트 를래스 객체를 넘겨줄 수 있음 data: 속성이나 상위컴포넌트에 받는 값으로 null이나{name: Azat} 같은 형태의 데이너 child: 자식 엘리먼트나 태그 내부에 작성하는 텍스트 12345var h1 = React.createElement('h1', null, 'Hello world!') //-h1요소를 생성하여 변수에 담음 ReactDOM.render( //h1요소를 ID가 content인 실제 DOM에 랜더링함 h1, document.getElementById('content') ) 아래처럼 변수에 담지 않고 직접 넣어줄수도 있다.12345ReactDOM.render( //h1요소를 ID가 content인 실제 DOM에 랜더링함 React.createElement('h1', null, 'Hello world!') document.getElementById('content')) 웹 브라우져에서 Hello world!객체가 만들어진것을 볼 수 있다.","link":"/2019/08/12/tec/react/react2/"},{"title":"[React 교과서] 6장 React 에서 이벤트 다루기","text":"리엑트 교과서를 정리한 내용입니다. 6.1 React에서 DOM이벤트 다루기아래 예제 코드는 이벤트 리스너에서 this를 콘솔에 표시하도록 한 코드. 여기서 event 객체는 내장 DOM이벤트를 객체를 개선한 것으로 합성 이벤트라고 부름 12345&lt;button onclick={(function(event){ console.log(this.event)}).bind(this)}&gt;Save&lt;/button&gt; 아래 경우에 bind(tnis)로 바인딩하지 않는다. this를 이용해서 해당 클래스를 참조 할 필요가 없을때 ES6+ 클래스 대신 예쩐방식인 React.createClass()를 사용할때. 이때는 createClass()가 자동으로 바인딩함. 화살표 함수(() =&gt; {})를 사용할 때 Reaact버전 15에서 지원하는 DOM 이벤트 이벤트 분류 React가 지원하는 이벤트 마우스 이벤트 onClick, onContentMenu, onDoubleClick, onDrag, onDragEnd, onDragEnter, onDragExit, onDragLeave, onDragOver, onDragStart, onDrop, onMouseDown, onMouseEnter, onMouseLeave, onMouseMove, onMouseOut, onMouseOver, onMouseUp 키보드 이벤트 onKeyDown, onKeyPress, onKeyup 클립보드 이벤트 onCopy, onCut, onPaste 폼 이벤트 onChange, onInpute, onSubmit, onTnvalid 포커스 이벤트 onFocus, onBlur 터치 이벤트 onTouchCancel, onTouchEnd, onTouchMove, onTouchStart UI이벤트 onScroll 휠 이벤트 onWheel 영역선택 이벤트 onSelect 이미지 이벤트 onLoad, onError 애니메이션 이벤트 onAnimationStart, onAnimationEnd, onAnimationIteration 트랜지션 이벤트 onTransitionEnd 6.1.1 캡쳐 및 버블링 단계12345678910111213141516class Mouse extends React.Component { render() { return &lt;div&gt; &lt;div style={{border: '1px solid red'}} onMouseOverCapture={((event)=&gt;{ console.log('mouse over on capture event') console.dir(event, this)}).bind(this)} onMouseOver={((event)=&gt;{ console.log('mouse over on bubbling event') console.dir(event, this)}).bind(this)} &gt; Open DevTools and move your mouse cursor over here &lt;/div&gt; &lt;/div&gt; }} 6.1.2 React이벤트 살펴보기6.1.3 React 합성 이벤트 객체 다루기12345678910111213class Mouse extends React.Component { render() { return &lt;div&gt; &lt;div style={{border: '1px solid red'}} onMouseOver={((event)=&gt;{ console.log('mouse is over with event') console.dir(event)}).bind(this)} &gt; Open DevTools and move your mouse cursor over here &lt;/div&gt; &lt;/div&gt; }} 6.1.4 이벤트와 상태 사용하기1234567891011121314151617181920class Content extends React.Component { constructor(props) { super(props) this.state = {counter: 0} } handleClick(event) { this.setState({counter: ++this.state.counter}) } render() { return ( &lt;div&gt; &lt;button onClick={this.handleClick.bind(this)} className=\"btn btn-primary\"&gt; Don't click me {this.state.counter} times! &lt;/button&gt; &lt;/div&gt; ) }} 6.1.5 이벤트 핸들러를 속성으로 전달하기123456789class ClickCounterButton extends React.Component { render() { return &lt;button onClick={this.props.handler} className=\"btn btn-danger\"&gt; Increase Volume (Current volume is {this.props.counter}) &lt;/button&gt; }} 6.1.6 컴포넌트 간의 데이터 교환123456789class ClickCounterButton extends React.Component { render() { return &lt;button onClick={this.props.handler} className=\"btn btn-info\"&gt; Don't touch me with your dirty hands! &lt;/button&gt; }} 12345678910111213141516171819class Content extends React.Component { constructor(props) { super(props) this.handleClick = this.handleClick.bind(this) this.state = {counter: 0} } handleClick(event) { this.setState({counter: ++this.state.counter}) } render() { return ( &lt;div&gt; &lt;ClickCounterButton handler={this.handleClick}/&gt; &lt;br/&gt; &lt;Counter value={this.state.counter}/&gt; &lt;/div&gt; ) }} 6.2 React가 지원하지 않는 DOM이벤트 처리하기1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Radio extends React.Component { constructor(props) { super(props) this.handleResize = this.handleResize.bind(this) let order = props.order let i = 1 this.state = { outerStyle: this.getStyle(4, i), innerStyle: this.getStyle(1, i), selectedStyle: this.getStyle(2, i), taggerStyle: {top: order*20, width: 25, height: 25} } } getStyle(i, m) { let value = i*m return { top: value, bottom: value, left: value, right: value, } } componentDidMount() { window.addEventListener('resize', this.handleResize) } componentWillUnmount() { window.removeEventListener('resize', this.handleResize) } handleResize(event) { let w = 1+ Math.round(window.innerWidth / 300) this.setState({ taggerStyle: {top: this.props.order*w*10, width: w*10, height: w*10}, textStyle: {left: w*13, fontSize: 7*w} }) } render() { return &lt;div&gt; &lt;div className=\"radio-tagger\" style={this.state.taggerStyle}&gt; &lt;input type=\"radio\" name={this.props.name} id={this.props.id}&gt; &lt;/input&gt; &lt;label htmlFor={this.props.id}&gt; &lt;div className=\"radio-text\" style={this.state.textStyle}&gt;{this.props.label}&lt;/div&gt; &lt;div className=\"radio-outer\" style={this.state.outerStyle}&gt; &lt;div className=\"radio-inner\" style={this.state.innerStyle}&gt; &lt;div className=\"radio-selected\" style={this.state.selectedStyle}&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/label&gt; &lt;/div&gt; &lt;/div&gt; }} 6.3 React를 다른 라이브러리와 통합하기: jQurey UI이벤트6.3.1. 버튼 통합하기방법1 jQuery슬라이더를 위한 이벤트를 React컴포넌트에서 등록하는 방법 12345678910111213141516171819202122232425262728293031323334353637class SliderButtons extends React.Component { constructor(props) { super(props) this.state = {sliderValue: 0} this.handleSlide = this.handleSlide.bind(this) this.handleChange = this.handleChange.bind(this) } handleSlide(event, ui) { this.setState({sliderValue: ui.value}) } handleChange(value) { return ()=&gt; { $('#slider').slider('value', this.state.sliderValue + value) this.setState({sliderValue: this.state.sliderValue + value}) } } componentDidMount() { $('#slider').on('slide', this.handleSlide) } componentWillUnmount() { $('#slider').off('slide', this.handleSlide) } render() { return &lt;div&gt; &lt;button disabled={(this.state.sliderValue&lt;1) ? true : false} className=\"btn default-btn\" onClick={this.handleChange(-1)}&gt; 1 Less ({this.state.sliderValue - 1}) &lt;/button&gt; &lt;button disabled={(this.state.sliderValue&gt;99) ? true : false} className=\"btn default-btn\" onClick={this.handleChange(1)}&gt; 1 More ({this.state.sliderValue + 1}) &lt;/button&gt; &lt;/div&gt; }} 6.3.2 라벨 통합하기123456789101112131415161718192021class SliderValue extends React.Component { constructor(props) { super(props) this.handleSlide = this.handleSlide.bind(this) this.state = {sliderValue: 0} } handleSlide(event) { this.setState({sliderValue: event.detail.ui.value}) } componentDidMount() { window.addEventListener('slide', this.handleSlide) } componentWillUnmount() { window.removeEventListener('slide', this.handleSlide) } render() { return &lt;div className=\"\" &gt; Value: {this.state.sliderValue} &lt;/div&gt; }}","link":"/2019/09/03/tec/react/react7/"},{"title":"[React 교과서] 2장 React 첫걸음","text":"리엑트 교과서를 정리한 내용입니다. 엘리먼트는 컴포넌트의 인스턴스이며 컴포넌트 클래스라고 한다. 2.1 엘리먼트 중첩여러개 엘리먼트가 중첩되는 경우가 많다.ReactDOM.render()에는 하나의 React엘리먼트만 인자로 전달할 수 있다.동일한 DOM객체에 두개의 h1태그를 렌더링해야 하는 경우 두 요소를 ``````으로 감싸 사용1234567```js var h1 = React.createElement(&apos;h1&apos;, null, &apos;Hello world!&apos;) //-h1요소를 생성하여 변수에 담음 var div = React.createElement(&apos;div&apos;, null, h1,h1) //-세번째 이후 매개변수가 문자열이 아니면 새로 생성하는 엘리먼트의 자식 엘리먼트다. ReactDOM.render( //h1요소를 ID가 content인 실제 DOM에 랜더링함 div, document.getElementById(&apos;content&apos;) ) createElement 의 첫번째 매개변수에는 아래 두가지 자료형을 입력할 수 있다. 문자열로 작성한 일반적 HTML태그. 소문자로 작성 ex) ‘h1’, ‘div’ React 컴포넌트 객체, HelloWorld를 예로 들 수 있음. React 컴포넌트 객체이름은 대문자로 시작한다. 2.2 React컴포넌트 클래스 생성컴포넌트 클래스(component class)를 사용하면 기능을 느슨하게 결합된 부분으로 분리하여 코드를 재사용할 수 있다.‘Hello world!’를 별도의 클래스로 분리하는 방법. class HelloWorld extends React.Component로 상속받아 사용12345678910let h1 = React.createElement('h1', null, 'Hello world!')class HelloWorld extends React.Component { render() { return React.createElement('div', null, h1, h1) }}ReactDOM.render( React.createElement(HelloWorld, null), document.getElementById('content')) 여기서 render()는 엘리먼트 하나만 반환함 Hello world!를 여러번 노출해야하면 아래와 같이 클래스 재사용 가능123456789ReactDOM.render( React.createElement(div, null, React.createElement(HelloWorld), React.createElement(HelloWorld), React.createElement(HelloWorld) ), document.getElementById('content' )) 2.3 React 속성(props) 사용하기컴포넌트의 속성(properties)은 React선언형 스타일의 기초다.1React.createElememt('a', {href: 'https://eunii.github.io'}) 속성은 컴포넌트 내부에서는 변경할 수 없는 값이다.부모 컴포넌트가 자식 생성 시점에 속성을 할당한다. 속성은 아래와 같은 용도로 사용가능 일반적 HTML 요소의 속성: href, title, style, class React 컴포넌트 클래스의 자바스크립트코드에서 this.props의 값. 예를 들어 this.props.PROPERTY_NAMErender()메서드에서 입력하여 렌더링하거나 코드에서 활용 할 수 있다. HelloWorld컴포넌트에 아래 세가지 속성을 추가한다. id frameworkHame titleid와 title은 h1의 표준속성과 일치에서 랜더링하고 frameworkName은 랜더링 하지 않는다. h1을 구현하기 전에 helloWorld클래스의 속성을 전달해야함.12345678910111213141516171819ReactDOM.render( React.createElement( 'div', null, React.createElement(HelloWorld, { id: 'ember', frameworkName: 'Ember.js', title: 'A framework for creating ambitious web applications.'}), React.createElement(HelloWorld, { id: 'backbone', frameworkName: 'Backbone.js', title: 'Backbone.js gives structure to web applications...'}), React.createElement(HelloWorld, { id: 'angular', frameworkName: 'Angular.js', title: 'Superheroic JavaScript MVW Framework'}) ), document.getElementById('content')) render()에서 frameworkName속성 사용하기12345678910class HelloWorld extends React.Component { render() { return React.createElement( 'h1', this.props, //모든 속성을 자식 엘리먼트에 전달한다. 'Hello ' + this.props.frameworkName + ' world!' ) }}","link":"/2019/08/13/tec/react/react3/"},{"title":"[SPRING] 6. DI(Dependency injection)","text":"인프런의 자바 스프링 프레임워크(ver.2018) - 신입 프로그래머를 위한 강좌를 보고 정리한 내용입니다. 6. DI(Dependency injection)6.1 DI(Dependency Injection)란? 배터리 일체형1234567public class ElectronicCarToy { private Battery battery; public ElectroniCarToy(){ battery = new NormalBattery(); }} 배터리가 떨어지면 장난감 새로 구입해야함 배터리 분리형 11234567891011public class ElectronicCarToy { private Battery battery; public ElectroniCarToy(){ } public void setBattery(Battery battery){ this.battery = battery; }} setBattery()를통해 배터리를 교체 할 수 있다. (처음에 배터리 없는 상태로 출시) 배터리 분리형 21234567891011public class ElectronicCarToy { private Battery battery; public ElectroniCarToy(Battery battery){ this.battery = battery; } public void setBattery(Battery battery){ this.battery = battery; }} setBattery()를통해 배터리를 교체 할 수 있다. (처음에 배터리 있는 상태로 출시)","link":"/2019/05/15/tec/spring/spring2/"},{"title":"[SQL] DDL(Data Definiation Language)","text":"*자동으로 COMMIT됨(AUTO COMMIT) 1.자주쓰이는 데이터 유형CHARCTER(s) 고정길이 문자열정보 (s)만큼의 최대 고정길이를 갖고 할당된 변수값의 길이가 s보다 작을때는 공백으로 채움 ‘AA’=’AA ‘ VARCHAR2(s) 가변길이 문자열정보 s만큼 최대값 입력가능, s이하의 변수길이값입력시 변수길이만큼 바이트적용 ‘AA’ != ‘AA ‘ NUMBER-정수, 실수 등 숫자정보 NUMBER(4,2) 8은 전체자리수, 2는 소수점 자리수(1234.56)를 나타냄 DATE-날짜와 시각정보 1초돤위로 관리* 2.CREATE TABLE테이블 생성식123456CREATE TABLE TABLENAME( COLUMNNAME1 DATATYPE [DEFAULT 형식] [NULL || NOT NULL], COLUMNNAME2 DATATYPE [DEFAULT 형식] [NULL || NOT NULL], ... COLUMNNAMEN DATATYPE [DEFAULT 형식] [NULL || NOT NULL]); 테이블 생성시 주의사항 벤더에서 정의한 예약어는 쓸 수 없음 A-Z(대소문자), 0-9, _, $, # 문자만 허용됨 테이블명 칼럼명 첫 글자는 반드시 문자로 와야함 제약조건(CONSTRAINT) 사용자가 원하는 조건의 데이터남 유지하기위한, 데이터 무결성을 유지하기위해 특정 칼럼에 설정하는 제약 테이블 생성시 추가하거나 테이블 생성후 ALTER TABLE 이용해서 추가할 수 있음 123456789101112131415161718192021222324252627282930313233343536ALTER TABLE MEMBERS ADD CONSTRAINT CK_MEMBERS_POINT CHECK(POINT&lt;10) NOVALIDATE;#PRIMARY KEY(기본키)-각 행의 고유의 식별 데이터-하나의 테이블당 한개만 설정 가능-NULL 입력 불가능#UNIQUE KEY(고유키)-행데이터를 고유하게 식별하기 위한 키-테이블당 여러개 설정 가능-NULL 입력 가능--기본키 및 외래키(TABLENAME1이름의 테이블이 생성되어 있다고 가정) 입력방법1CREATE TABLE TABLENAME( COLUMNNAME1 DATATYPE [DEFAULT 형식] [NOT NULL], COLUMNNAME2 DATATYPE [DEFAULT 형식] [NOT NULL], ... COLUMNNAMEN DATATYPE [DEFAULT 형식] [NOT NULL], CONSTRAINT PK_TABLENAME_COLUMNNAME1 PRIMARY KEY(COLUMNNAME1), CONSTRAINT FK_TABLENAME_COLUMNNAME2 FOREGIN KEY(COLUMNNAME2) REFERENCES TABLENAME2(COLMNUMNAME1) );--기본키 입력방법2CREATE TABLE TABLENAME( COLUMNNAME1 DATATYPE PRIMARYKEY [NOT NULL], COLUMNNAME2 DATATYPE [DEFAULT 형식] [NOT NULL], ... COLUMNNAMEN DATATYPE [DEFAULT 형식] [NOT NULL], );--기본키 및 외래키(TABLENAME1이름의 테이블이 생성되어 있다고 가정) 입력방법3--테이블 생성 후(테이블 명 = TABLENAME)ALTER TABLE TABLENAME ADD CONSTRAINT PK_TABLENAME_COLUMNNAME1 PRIMARYKEY(COLUMNNAME1);ALTER TABLE TABLENAMEADD CONSTRAINT FK_TABLENAME_COLUMNNAME2 FOREGIN KEY(COLUMNNAME2) REFERENCES TABLENAME2(COLMNUMNAME1)--기본키 및 외래키 삭제ALTER TABLE TABLENAMEDROP CONSTRAINT PK_TABLENAME_CONLUNMNAME1;ALTER TABLE TABLENAMEDROP CONSTRAINT FK_TABLENAME_CONLUMNNAME2; NOT NULL NULL 값 입력금지 DEFAULT상태에서는 NULL 허가 NULL : 공백(“”), 숫자0이 아님, 정의되지 않은 미지의 값, 현재 데이터를 입력하지 못하는 경우NULL + 0 = NULL;NULL + ‘CHAR’ = NULL; CHECK 입력할수 있는 값의 범위를 제한 FOREIGN KEY(외래키) 관계형데이터베이스에서 테이블간의 관계를 정의하기 위해 기본키를 다른 테이블의 외래키로 복사하는 경우 외래키 생성 외래키 지정시 참조 무결성 제약옵선 선택가능 생성된 테이블 구조확인1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859DESCRIBE TABLENAME;DESC TABLENAME;``` ### SELECT 문장을 통한 테이블 생성 TABLENAME과 같은 내용의 테이블 TABLENAME1을 복사해서 생성 ```sqlCREATE TABLE TABLENAME1AS SELECT * FROM TABLENAME;``` ## 3.ALTER TABLE### ADD COLUMN- 테이블에 컬럼 추가 - 추가된 칼럼은 테이블의 마지막 컬럼이 되고 컬럼위치를 지정하는것은 불가능 ```sqlALTER TABLE TABLENAME ADD NEWCOLUMNNAME DATATYPE;``` ### DROP COLUNM - 컬럼 삭제- 데이터유무에 상관없이 삭제 가능- 한번에 하나의 칼럼만 삭제가능 - 삭제후 최소 하나이상의 칼럼이 테이블에 존재해야함- 삭제된 갈럼은 복구 불가능```sqlALTER TABLE TABLENAME DROP COLUMN COLUMNNAME1;``` ### MODIFY COLUMN- 칼럼 데이터 유형, 디폴트값(DEFAULT), NOT NULLL 제약조건 변경- 칼럼의 크기를 늘릴 수는 있지만 줄일수는 없음(기존데이터 훼손방지)- 칼럼이 NULL 값만 가지고 있으면 데이터 유형 변경가능\\- 칼럼에 행이 없거나 NULL값만 가지고 있으면 칼럼의 폭 줄이기 가능- DEFALUT값 변경시, 변경작업 이후 발생하는 행 삽입에만 영향을 미침- 칼럼에 NULL값이 없을 경우에만 NOT NULL 제약조건을 추가할 수 있음 ```sqlALTER TABLE TABLENAME MONIFY (COLUMNNAME1 DATATYPE [DEFAULT] [NOT NULL], COLUMNNAME2 DATATYPE [DEFAULT] [NOT NULL], ... COLUMNNAMEN DATATYPE [DEFAULT] [NOT NULL]); ``` ### RENAME COLUMN - 칼럼명 변경- 해당 칼럼과 관계된 제약조건이 자동으로 변경```sqlALTER TABLE TABLENAMERENAME COLUMN COLUMNNAME TO NEWCOLUMNNAME; DROP CONSTRAINT 테이블 생성시 부여했던 제약조건 삭제 12345678910111213141516171819202122232425262728293031323334353637383940414243444546ALTER TABLE TABLENAMEDROP CONSTRAINT PK_TABELNAME_COLUMNNNAME;``` ### ADD CONSTRAINT - 제약조건 추가- 외래키설정하면 참조된 테이블의 데이터 삭제가 불가능 할수도 있음 ```sqlALTER TABLE TALBENAMEADD CONSTRAINT PK_TALBENAME_COLUMNNAME PRIMARY KEY(COLUMNNAME);ALTER TABLE TABLENAMEADD CONSTRAINT FK_TABLENAME_COLUMNNAME FOREGIN KEY(COLUMNNAME) REFERENCES TABLENAME1(COLUMNNAME1); ``` ## 4. RENAEM TABLE### RENAME TABLE- 테이블 이름변경```sqlRENAME TABLE TABLENAME TO NEWTABLENAME;``` ## 5.DROP TABLE### DROPT TABLE- 테이블 삭제- CASCADE CONSTRAINT는 해당 테이블과 관계있던 참조 제약조건도 삭제한다는 뜻```sqlDROP TABLE TABLENAME [CASCADE CONSTRAINT];``` ## 6. TRUNCATE TABLE### TURNCATE TABLE- 테이블의 모든 행(데이터)삭제- DML로 분류할수도 있지만 AOUTO COMMIT특성이 있어 DDL로도 구분가능- DELETE와는 다름 - 정상적인복구가 불가능 ```sqlTURNCATE TABLE TABLENAME;","link":"/2019/04/10/tec/sql/sql1/"},{"title":"[SQL] GROUP BY, HAVING절","text":"1. 집계함수(AGGREGATE FUNCTION) 여러 행들의 그룹이 모여 그룹당 하나의 결과를 리턴하는 함수 GROUP BY 절은 행들을 소그룹화 함 SELECT절, HAVING절, ORDER BY 절에 사용할 수 있음. 집계함수명([DISTINCT] 칼럼이나 표현식)COUNT(*) NULL값을 포함한 행의 수 출력COUNT(표현식) 표현식의 값이 NULL값을 제외한 행의 수 출력SUM([DISTINCT] 표현식) NULL값을 제외한 합계출력AVG([DISTINCT] 표현식) NULL값을 제외한 평균출력MAX([DISTINCT] 표현식) 표현식의 최대값 출력MIN([DISTINCT] 표현식) 표현식의 최소값 출력STDDEV([D] 표현식) 표현식의 표준편차 출력VARIAN([D] 표현식) 표현식의 분산 출력 2. GROUP BY절 SQL문에서 FROM과 WHERE절 뒤에 위치, 데이터를 그룹으로 분류하여 소그룹에대한 항목별 통계정보를 얻을때 사용 12345SELECT [DISTINCT] 칼럼명 [ALIAS명]FROM 테이블명[WHERE 조건식][GROUP BY 칼럼이나 표현식][HAVING 그룹조건식]; GROUP BY, HAVING절의 특성 그룹바이로 소그룹의 기준을 정한후, SELECT 절에 집계함수를 사용 집계함수의 통계정보는 NULL값을 제외하고 수행함 WHERE절에는 집계함수 올 수 없음 HAVING절은 그룹바이절의 기준 항목이나 소그룹의 집계함수를 이용한 저건을 표시 그룹바이절에 의해 소그룹별로 만들어진 집계데이터 중, HAVING 절에 제한 조건을 두어 만족하는 내용만 출력 HAVING절은 일반적으로 GROUP BY절 뒤에 위치 1234567891011121314SELECT POSITION 포지션, AVG(HEIGHT) 평균키FROM PLAYER;--&gt;&gt;ERROR : 단일 그룹의 집계함수가 아니다라고 나옴SELECT POSITION 포지션, AVG(HEIGHT) 평균키FROM PLAYERGROUP BY POSITION 포지션;--&gt;&gt;ERROR SQL명령어가 올바르게 종료되지 않음--&gt;그룹바이에 별명ALIAS쓸 수 없음--포지션별 최대키, 최소키, 평균키 출력SELECT POSITION 포지션, MAX(HEIGHT), MIN(HEIGHT), AVG(HEIGHT)FROM PLAYERGROUP BY PISITION; 3.HAVING 절 GROUP BY후에 조건을 달고 싶을때 WHERE 대신 씀 WHERE절은 GROUP BY절 전에 오기때문에 소그룹으로 묶인후의 조건을 걸 수없음. 123456789101112131415161718SELECT POSITION 포지션, ROUND(AVG(HEIGHT),2) 평균키FROM PLAYERWHERE AVG(HIGHT) &gt;=180GROUP BY POSITION--3행오류 : 집계함수가 허가되지 않음. 그룹바이로 소그룹화 되기전에 집계함수를 사용했기때문.SELECT POSITION, ROUND(AVG(HEIGHT),2)FROM PLAYERGROUP BY POSITIONHAVING AVG(HEIGNT)&gt;=180;--이렇게써야함--예제)--최대 키가 190CM이상인 선수를 가지고 포지션별 평균 키를 출력SELECT POSICITON AVG(HEIGHT)FROM PLAYERGROUP BY POSITIONHAVING MAX(HEIGHT) &gt;=190; 4. CASE 표현을 활용한 월별 데이터 집계 모델링의 제 1정규화로 반독되는 칼럼의 경우, 구분칼럼을 두고 여러개의 레코드로 만들어진 집합을 정해진 칼럼 수만큼 확장해서 집계 보고서를 만드는 유용한 기법 예제)부서별 월별 입사자의 평균 급여를 조회, 입사후 1년마다 급여 인상이나 보너스 지급과 같은 일정이 정기적으로 잡히면 업무적으로 중요한 정보가 됨 123456789101112131415161718192021222324252627--STEPT1--개별입사정보에서 월별데이터 추출SELECT ENAME, DEPOTNO, EXTRACT(MONTH FROM HIREDATE) MONTH, SALFROM EMP;--STEPT2 월별데이터 구분SELECT ENAME, DEPTNO, CASE MONTH WHEN 1 THEN SAL END M01, CASE MONTH WHEN 2 THEN SAL END M02, CASE MONTH WHEN 3 THEN SAL END M03, CASE MONTH WHEN 4 THEN SAL END M04, CASE MONTH WHEN 5 THEN SAL END M05, CASE MONTH WHEN 6 THEN SAL END M06, CASE MONTH WHEN 7 THEN SAL END M07, CASE MONTH WHEN 8 THEN SAL END M08, CASE MONTH WHEN 9 THEN SAL END M09, CASE MONTH WHEN 10 THEN SAL END M10, CASE MONTH WHEN 11 THEN SAL END M11, CASE MONTH WHEN 12 THEN SAL END M12FROM (SELECT ENAME, DEPTNO, EXTRACT(MONTH FROM HIREDATE) MONTH, SAL FROM EMP); --STEPT3 2의구분을 부서별로 그룹화SELECT DEPTNO, AVG(CASE MONTH WHEN 1 THEN SAL END) M01, AVG(CASE MONTH WHEN 2 THEN SAL END) M02, AVG(CASE MONTH WHEN 3 THEN SAL END) M03, AVG(CASE MONTH WHEN 4 THEN SAL END) M04, AVG(CASE MONTH WHEN 5 THEN SAL END) M05, AVG(CASE MONTH WHEN 6 THEN SAL END) M06, AVG(CASE MONTH WHEN 7 THEN SAL END) M07, AVG(CASE MONTH WHEN 8 THEN SAL END) M08, AVG(CASE MONTH WHEN 9 THEN SAL END) M09, AVG(CASE MONTH WHEN 10 THEN SAL END) M10, AVG(CASE MONTH WHEN 11 THEN SAL END) M11, AVG(CASE MONTH WHEN 12 THEN SAL END) M12FROM (SELECT ENAME, DEPTNO, EXTRACT(MONTH FROM HIREDATE) MONTH, SAL FROM EMP)GROUP BY DEPTNO; 5.집계함수와 NULL처리 빈칸을 NULL이 아니라 0으로 처리하기 위해 NVL()을 사용하는 경우가 있는데, 오히려 불필요할 수 있음 행 함수는 건수가 NULL인 행을 빼고 계산함. SUM, AVG,..등 굳이 0을넣어 불필요하게 더 계산할 필요가 없음 ELSE 절 생략하면 DEFAULT 값이 NULL임 출력시 NULL이 아닌 0을 표현하고싶으면 NVL(SUM(SAL),0)이렇게 하면됨","link":"/2019/04/15/tec/sql/sql6/"},{"title":"[SQL] TCL(TRANSACTION CONTROL LANGUAGE)","text":"1.개요 데이터베이스의 논리적 연산단위 한 개 이상의 데이터베이스 조작단위(하나 이상의 SQL구문포함) ALL OR NOTHING개념 특성 : 원자성(atomicity)-정의된 연산이 모두 성공해야함.하나라도 실패시 모두 실행하지 않음. 일관성(consistency)-실행전에 내용잘못이 없다면 실행후 데이터베이스의 내용에 잘못이 있으면 안 됨 고립성(isolation)-다른 트랜잭션의 영향을 받으면 안 됨 지속성(durability)-성공한 트랜잭션이 생신한 데이터베이스내용은 영구적으로 저장 2.COMMITCOMMIT 입력이나 수정한 자료를 저장하고싶을때 COMMIT명령을 내려 저장(COMMIT전) BUFFER에만 영향을 받았기에 데이터 변경 이전상태로 복구가능 현재 사용자가 SELECT 문장으로 결과 확인 가능 다른 사용자는 현재 사용자가 수행한 명령의 결과를 볼 수 없음 변경된 행은 잠금(LOCKING)이 설정되어 다른 사용자가 변경할 수없음(COMMIT후) 데이터 변경사항이 데이터베이스에 반영 이전데이터 영구삭제 모든 사용자가 결과 확인가능 관련된 행의 잠금이 해제, 다른사용자들이 조작가능 12-- 데이터 수정 변경 후COMMIT; AUTO COMMIT(SQL Sever방식) DDL,DML이 수행될 때마다 DBMS가 트랜잭션 컨트롤하는방식,명령이 성공적으로 수행되면 자동으로 COMMTI,실패하면 ROLLBACK됨 암시적트랜잭션(ORACLE방식) 트랜젝션 시작은 DBMS가, 끝은 사용자가 COMMIT, ROLLBACK으로 처리 명시적트랜잭션 트랜젝션 시작과 끝을 사용자가 BEGIN TRANSACTION || COMMIT TRANSACTION ,ROLLBACK TRANSACTION으로 처리 3.ROLLBACKROLLBACK 데이터 이전상태로 복구, 관련된 행에 대한 잠금이 풀림12345678910111213141516171819--데이터 수정 변경 후ROLLBACK;``` ## 4.SAVEPOINT### SAVEPOINT- ROLLBACK이 실행될 저장점을 지정- 복수저장점 정의가능- 먼저 정의된 SAVEPOINT로 롤백할 경우 이후 저장된 SAVEPOINT로 되돌릴 수 없음- DDL문장을 실행하면 자동커밋됨- DML 명령 후 DDL명령을 입력시 DML, DDL 명령모두 자동커밋- 데이터베이스 정상종료하면 자동 커밋- 어플리케이션 이상 종료는 자동 롤백```sqlSAVEPOINT SVPT1;ROLLBACT TO SVPT1;SAVE TRANSACTION SVPT2;ROLLBACK TRANSACTION SVPT2;","link":"/2019/04/12/tec/sql/sql3/"},{"title":"[SQL] ORDER BY 정렬","text":"1. ORDER BY 정렬123456SELECT 칼럼명 [ALIAS명]FROM 테이블명[WHERE 조건식][GROUP BY 칼럼또는 표현식][HAVING 그룹조건식][ORDER BY 칼럼이나 표현식 [ASC 또는 DESC]; 2.SELECT 문장실행 순서5)SELECT1)FROM2)WHERE3)GROUP BY4)HAVING6)ORDER BY 12345678SELECT DNAME, LOC, DEPTNOFROM DEPTORDER BY 1,2,3 DESC;SELECT JOB FROM EMPGROUP BY JOBHAVING COUNT(*)&gt;0ORDER BY MAX(EMPNO), MAX(MGR), SUM(SAL), COUNT(DEPTNO), MAX(HIREDATE); 3. TOP N 쿼리ROWNUM12345678910--ORDER BY가 제일 늦게 실행되기 때문에 원하는 값이 안 나옴SELECT ENAME, SAL FROM EMPWHERE ROWNUM &lt;4ORDER BY SAL;--2중쿼리 이용SELECT ENAME, SALFROM (SELECT ENAME, SAL FROM EMP ORDER BY SAL DESC)WHERE ROWNUM&lt;4;","link":"/2019/04/16/tec/sql/sql7/"},{"title":"[DAY -1] 아이슬란드로","text":"운이 좋게 가족 모두 2주정도 시간이 생겨 첫 가족 해외여행 기회가 찾아왔다.오로라 보러갈래?내가던진 한마디에 엄빠가 짠듯이 케나다 옐로나이프를 찾아오셨다.오로라가 유명하지만-30도. 여행 일정을 대충 짠 다음에 비행기표를 예약했다.결제 직전 언니 일정때문에 하루만 더 생각해보자고 하고 결제를 미뤘다.하루가 지나고 여행지가 변경됐다.아이슬란드로.엄마가 생소한 여행지여서 탐탁치 않아하셨지만 어떻게 설득을했다.결론적으로 너무 잘된 결정이었던것 같다. 어딜가든 좋았겠지만가족들끼리 그렇게 하루종일 오랜시간 같이 지내는것도 오랜만이었다.","link":"/2019/03/09/trip/europ/iceland1/"},{"title":"[DAY 4] 스카이루스 게스트하우스","text":"여태껏 숙소는 다 개별룸으로 지냈는데방이 없어서 이날 하루 게스트 하우스에서 지냈다.깐깐해보이는 주인 아줌마가 계셨는데 친절했다.공용주방이 너무 작아서 두팀밖에 밥을 못 먹었다.공용화장실이지만 그래도 깨끗했다.아침에 시끄러운 공사소리가 기억에 남는다.","link":"/2019/03/19/trip/europ/iceland11/"},{"title":"[소켓통신/websocket] Spring boot로 소켓통신 채팅 웹 페이지 만들기","text":"1.Spring boot로 웹 소켓통신 채팅 페이지 만들기2. STS에서 Spirng project 만들기2.1 files - new - Spring Start Project 클릭 2.2 아래와 같이 입력(프로젝트 이름 등) - next클릭 2.3 Available에web 검색 후 WebSocket, Spring web start 체크 후 Finish 클릭 2.4 pom.xml에 다음과 같은 디펜던시 추가 됐는지 확인한다.123456789101112&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web-services&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-websocket&lt;/artifactId&gt; &lt;/dependency&gt; 아래 디펜던시를 추가한다.1234&lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt;&lt;/dependency&gt; 2.5 src/main/webapp/WEB-INF/jsp 폴더를 만든다 2.6 src/main/resources/application.properites에 아래 내용을 추가한다.12spring.mvc.view.prefix=/WEB-INF/jsp/spring.mvc.view.suffix=.jsp 2.7 src/main/ io.github.eunii.chatting/ChattingApplication.java에 @config 어노테이션을 추가한다.12345678910111213141516package io.github.eunii.chatting;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.context.annotation.Configuration;@SpringBootApplication@Configurationpublic class ChattingApplication { public static void main(String[] args) { SpringApplication.run(ChattingApplication.class, args); }} 3. src/main/java 아래 io.github.eunii.chatting.config 패키지를 만들고 아래 내용의 WebScoketConfig.java 파일을 만든다.12345678910111213141516171819202122package io.github.eunii.chatting.config;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.annotation.Configuration;import org.springframework.web.socket.config.annotation.EnableWebSocket;import org.springframework.web.socket.config.annotation.WebSocketConfigurer;import org.springframework.web.socket.config.annotation.WebSocketHandlerRegistry;import io.github.eunii.chatting.handler.SocketTextHandler;@Configuration@EnableWebSocketpublic class WebSocketConfig implements WebSocketConfigurer { @Autowired SocketTextHandler socketTextHandler; public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) { registry.addHandler(socketTextHandler, \"/chat\"); }} /chat 으로 호출이 오면 SocketTestHandler를 실행한다는 뜻이다. 4 src/main/java 아래 io.github.eunii.chatting.handler 패키지를 만들고 아래 내용의 SocketTextHandler.java 파일을 만든다.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package io.github.eunii.chatting.handler;import java.io.IOException;import java.util.HashMap;import org.springframework.stereotype.Component;import org.springframework.web.socket.CloseStatus;import org.springframework.web.socket.TextMessage;import org.springframework.web.socket.WebSocketSession;import org.springframework.web.socket.handler.TextWebSocketHandler;@Componentpublic class SocketTextHandler extends TextWebSocketHandler {// ArrayList&lt;WebSocketSession&gt; sessions = new ArrayList&lt;&gt;(); HashMap&lt;String, WebSocketSession&gt; sessions = new HashMap&lt;&gt;(); // client에서 메시지가 서버로 전송댈때 실행되는 함수. @Override public void handleTextMessage(WebSocketSession session, TextMessage message) { String payload = message.getPayload(); try { // 접속된 모든 세션에 메시지 전송 for (String key : sessions.keySet()) { WebSocketSession ss = sessions.get(key); ss.sendMessage(new TextMessage(payload)); } } catch (IOException e) { // TODO Auto-generated catch block e.printStackTrace(); } } // 세션이 생성될때 시작되는 함수 @Override public void afterConnectionEstablished(WebSocketSession session) throws Exception { super.afterConnectionEstablished(session); sessions.put(session.getId(), session); } // 세션이 끝날때 실행되는 함수 @Override public void afterConnectionClosed(WebSocketSession session, CloseStatus status) throws Exception { sessions.remove(session.getId()); super.afterConnectionClosed(session, status); }} handleTextMessage(WebSocketSession session, TextMessage message) 함수는 클라이언트에서 ws.send(data)가 호출되면 실행된다. afterConnectionEstablished()는 세션이 시작될때 실행되는 함수이다. 여기선 sessions에 생성된 세션 정보를 저장한다. afterConnectionClosed()는 세션이 끊길때 실행되는 함수. 여기선 sessions에 저장된 세션 정보를 지운다. 4. Client jps 페이지 만들기 src/main/webapp/WEB-INF/jsp에 chat.jsp파일을 만든다.1234567891011121314151617181920212223242526272829303132333435363738394041&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;script src=&quot;https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;script type=&quot;text/javascript&quot;&gt; var ws; function connectWs() { ws = new WebSocket(&apos;ws://&apos; + location.host + &apos;/chat&apos;); ws.onmessage = function(data) { console.log(data.data); $(&quot;&lt;p&gt;&quot;+data.data+&quot;&lt;/p&gt;&quot;).prependTo(&apos;#chat&apos;); } $(&apos;#startBtn&apos;).hide(); } function send() { ws.send($(&quot;#chatting&quot;).val()); $(&apos;#chatting&apos;).val(&quot;&quot;); }&lt;/script&gt;&lt;body&gt; &lt;h1&gt;채팅 방 입니다&lt;/h1&gt; &lt;button onclick=&quot;connectWs()&quot; id=&quot;startBtn&quot;&gt; 채팅 시작하기&lt;/button&gt; &lt;input id=&quot;chatting&quot;&gt;&lt;/input&gt;&lt;button onclick=&quot;send()&quot;&gt; 보내기 &lt;/button&gt; &lt;div&gt; &lt;p id=&quot;chat&quot;&gt;&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; jquery를 추가한다. 채팅 시작하기 버튼을 만들어 connectWs() 함수로 소켓을 연다. ws.onmessage = function(data) {} 함수는 서버에서 handleTextMessage()가 실행되어 전송해준 data를 받는다. ws.send(“STRING”) 함수는 send()함수가 실행될때마다 handleTextMessage(WebSocketSession session, TextMessage message)에 message정보를 보낸다. 5 src/main/java 아래 io.github.eunii.chatting.controller 패키지를 만들고 아래 내용의 MainController.java 파일을 만든다.12345678910111213141516package io.github.eunii.chatting.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.servlet.ModelAndView;@Controllerpublic class MainController { @RequestMapping(\"/\") public ModelAndView home() { ModelAndView mv = new ModelAndView(\"chat\"); return mv; }} 6. start as Spring boot app으로 서버를 실행한다. 7. 두개의 브라우저에서 http://localhost:8080/ 창을 띄운다. 8. 채팅 시작하기를 누른다. 9. 메시지를 전송해 본다.","link":"/2019/06/22/tec/spring/socket1/"},{"title":"[DAY 5] 다이아몬드 비치-빙하 해변","text":"요쿨살론 근처에 다이아몬드 비치가 있다.두군데가 있는데 아무곳이나 봐도 이쁘다.아침 햇살에 빙하가 너무 아름다웠다.왜 다이아몬드 비치라고 불리는지 너무나 이해가 갔다.바닷가에서 수달? 같은것도 봤다.오래있고 싶었지만 바닷물이 슬슬 들어오는것 같기도 하고..다음여행지가 밀려있어서 잠깐 보구 출발했다.","link":"/2019/03/21/trip/europ/iceland13/"},{"title":"[SQL] DML(DATA MANIPULATION LANGUAGE)","text":"생성된 테이블안에 데이터를 입력, 수정,삭제, 조회 하는 언어 AUTO COMMIT이 되질 않음 입력후 COMMIT하면 저장, ROLLBACK하면 SAVEPOINT나 제일 최근 COMMIT전으로 돌아감 1. INSERTINSERT 한번에 한건의 행만 입력됨 123456789101112131415161718192021--원하는 칼럼에만 데이터 입력하는 방법--칼럼명 입력하지 않은 칼럼은 NULL이나 DEFALUT값 입력됨INSERT INTO 테이블명 (칼럼명1, 칼럼명2, ... , 칼럼명N)VALUES (값1, 값2,..., 값N); --테이블에 설정된 모든 컬럼에 데이터 입력하는 방법--생성한 컬럼 순서대로 모든 값을 입력INSERT INTO 테이블명VALUES (값1, 값2, ...,값N);``` ## 2.UPDATE### UPDATE- 데이터 수정- WHERE절을 사용하지 않으면 컬럼 전체가 수정할 값으로 변경됨```sqlUPDATE 테이블명 SET 수정할값이있는컬럼명 = 수정할값 [WHERE 조건입력]; 3.DELETEDELETE 데이터삭제 WHERE절 사용하지 않으면 컬럼전체 DATA가 삭제됨 1DELETE [FROM] 테이블명 [WHERE 조건입력]; 4. SELECTSELECT 사용자가 입력한 데이터 조회 DISTINCT옵션(ALL은 DEFAULT옵션임) : 중복된 데이터가 있으면 1번만 출력 *은 WILDCARD 모든 컬럼 ALIAS 컬럼에 별명붙이기: 컬럼바로 뒤에 옴, AS 생략가능&quot;&quot;는 공백, 특수문자를 포함할경우, 대소문자 구별이 필요할 경우 사용 테이블에 있는 모든 데이터 조회(WILDCARD * 사용) 1SELECT [ALL | DISTINCT] * FROM 테이블명 테이블에 있는 원하는 컬럼에 있는 데이터 조회(+별명붙이기) 12SELECT 컬럼명1 [[AS] \"벌명1\"], 컬럼명2 [[AS] \"별명2\"], ..., 컬럼명3 [[AS] \"별명3\"] FROM 테이블명; DISTINCT옵션 1SELECT DISTINCT 칼럼명1 FROM 테이블명; 5.산술연산자 합성연산자산술연산자(NUMBER자료형에 사용)()연산자 우선순위 괄호‘* ‘‘/‘‘+’‘-‘ (CONCATENATION)합성연산자 문자와 문자의 연결 ‘||’ 사용 CONCAT(STRING1, STRING2) 칼럼과 문자 또는 다른 칼럼과 연결 문자표현식의 결과의해 새로운 칼럼 생성 산술연산자 예제 1234567SELECT 칼럼명(숫자데이터타입)-칼럼명(숫자데이터타입) AS 차이 FROM 테이블명;``` - 합성연산자 예제 ```sqlSELECT 칼럼명(STRING데이터타입) || 칼럼명(STRING데이터타입) AS 문자열합 FROM 테이블명;","link":"/2019/04/11/tec/sql/sql2/"},{"title":"[DAY 5] 디위피보귀르-어촌마을","text":"오늘은 관광보다는 이동이 주 목적이었다.아이슬란드 두번째 도시 에이일스타디르에 도착해야했다.차를 오래 타면 힘드니까 중간 어촌도시에 내려서 쉬어갔다.기름도 넣고 네토에서 장도 봤다.네토마트는 전반적으로 보너스마트 보다 비싸다..항구도 있는 예쁜마을이었다.여기서 하루를 보냈어도 좋았을것 같다.아직 에이일스타디르까지 갈 길이 멀다.","link":"/2019/03/22/trip/europ/iceland14/"},{"title":"[DAY 6] 세이디스피외르뒤르","text":"아침에 일어나보니 눈이 많이 쌓여있었다.여행일정중 가장 많은 눈이 쌓였다고 생각했다.그래도 새로운 곳으로 떠나보기로 했다.아빠가 제일 가보고 싶어했던 세이디스피외르뒤르.월터의 현실은 상상이 된다에 나왔던 곳이다.월터가 스케이트 보드 타고 달리던 그 푸른 길을우리는 눈과 싸우며 조심히 드라이브 했다. 도시에 들어갈수록 길이 위험해지고 눈이 많이 내렸다.도착했을땐 하얀 마을이 보였다.눈이 없다면 알록달록 파스텔 톤의 이쁜 마을이었을 것 같다.시그니쳐 하늘색 교회에서 사진을 찍고.더 눈이 많이 내리기 전에 빨리 출발하기로 했다.정말 눈이 많이왔다.","link":"/2019/03/24/trip/europ/iceland16/"},{"title":"[SPRING] 1. 스프링 개요","text":"인프런의 자바 스프링 프레임워크(ver.2018) - 신입 프로그래머를 위한 강좌를 보고 정리한 내용입니다. 1. 스프링개요1.1 스프링프레임워크스프링프레임워크는 주요기능으로 DI. AOP, MVC, JDBC등을 제공한다. 1.2 스프링 프레임워크 모듈 스프링모듈 기능 spring-core 스프링의 핵심인 DI(Depenency Injection)과 IoC(Inversion of Control)을 제공 spring-aop AOP 구현 기능 제공 spring-jdbc 데이터베이스를 쉽게 다룰 수 있는 기능 제공 spring-tx 스프링에서 제공하는 트랜젝션 관련 기능 spring-webmvc 스프링에서 제공하는 컨트롤러(Controller)와 뷰(View)를 이용한 MVC구현 기능 제공 1.3 스프링 컨테이너(IoC)스프링에서 객체를 생성하고 조립하는 컨테이너(contatiner)로, 컨테이너를 통해 생성된 객체를 빈(Bean)이라고 부른다. 객체생성 및 속성 데이터 작성(xml문서) 스프링컨테이너에서 객체 생성 및 조립 애플리케이션 구현(개발 문서)","link":"/2019/05/15/tec/spring/spring1/"},{"title":"[DAY 6] 미바튼 숙소 외딴 코지","text":"테티포스에서 한바탕 고생을 한탓에 우리는 빨리 숙소에 들어가서 쉬고싶었다.1번 링로드와 완전 가까운 숙소를 예약했다.약간의 문제가 있었다.눈이 많이 쌓여서 차를 숙소까지 가져갈 수가 없었다.차는 큰도로 옆 공터에 대고, 우리가 하루동안 필요한 짐만 캐리어에 챙겨서 눈밭을 굴러 내려갔다.차가 있는 위치와 숙소는 경사가 심했고 길이 보이지 않아 호스트 아저씨가 길을 걸으며 내 주었다.우리는 길을 더 크게 내며 킬킬거리며 걸었다. 숙소는 깔끔하고 좋았다.다락방 작은 창에서는 별이 아주 잘 보였다. 고생한 우리를 위해 엄마가 닭볶음탕을 해주셨다.먹고 다들 뻗어서 쉬었다. 자다 일어니 창밖에서 오로라가 보였다.언능 식구들을 다 깨워서 이번엔 의자를 가지고 밖으로 나갔다.옆 숙소 불빛이 넘 밝아 아쉬웠지만 이렇게 별이 많은 하늘은 처음 봤다.나름 별 보는 것을 좋아해서 여러 나라에서 별을 보러 다녔는데 미바튼에서 본 하늘은 정말 최고였다.그렇게 세번째 오로라를 볼 수 있었다.실컷 또 하늘을 구경하고 야식으로 라면을 먹고 잤다.","link":"/2019/03/26/trip/europ/iceland18/"},{"title":"[DAY 4] 스카프타펠-빙하 투어","text":"전날밤 스카프타펠 빙하트레킹 투어를 신청했다.두시시작이었나.눈이 와서 걱정했는데 다행이 투어시간에는 눈이 안 왔다.빙하사이를 걷는것은 굉장한 일이라고 생갔했었다.멀리서 눈에 덮인 빙하가 보였다.빙하가 아니라 눈으로 보였다.푸른 얼음 덩어리를 기대한 나는 조금 실망하기는 했다.그래도 언제 빙하를 걸어 보겠어.신기하긴했다. 제시카 가이드가 사진찍는 시간도 많이 주고설명도 친절하게 잘 해줬다.얼음동굴도 들어가봤다.얼음이 천천히 녹아 동굴이 생긴거다.겨울에만 볼 수 있는 투어여서 특별했다.위험해서 걷는 도중에 사진을 찍을 수 는 없었는데고프로를 머리에 붙이고 가서 동영상은 건질 수 있었다.노을을 내내보며 빙하 트레킹 하는것도 나쁘지는 않았다.","link":"/2019/03/18/trip/europ/iceland10/"},{"title":"[SQL] WHERE절","text":"1. 연산자 종류비교연산자123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167=&gt;&lt;=&gt;&gt;=``` ### SQL연산자- BETWEEN a AND b (a 이상, b이하의 값)- IN(a,b,c) (a,b,c중 하나라도 일치하는 값이 있으면 true)- LKIE &apos;비교문자열&apos; 비교문자열과 형태일치(%, _)- IS NULL NULL인 경우(=NULL은 사용할 수 없음) ### 논리연산자- AND- OR- NOT ### 부정비교연산자 - != (같지 않다)- NOT 칼럼명= a (칼럼명의 값과 a가 같지 않다)- NOT 칼럼명 &gt; a (a보다 칼럼명의 값이 크다) ### 부정SQL연산자- NOT BETWEEN a AND b (a와 b사이에 있지 않다. a,b 포함하지 않음)- NOT IN(a,b,c) (a,b,c값과 일치 하지 않음)- IS NOT NULL (NULL 값을 갖지 않음, !=NULL 사용불가) ## 2.비교연산자- STRING은 &apos;&apos;나 &quot;&quot;으로 묶어서 사용- 숫자는 &quot;&quot;,&apos;&apos;사용 안 함예제) COFFEELIST 테이블에서 브랜드가 스타벅스 커피중에 가격이 5000원 이하이고 용량이 200m이상인 커피의 브랜드, 종류, 가격, 용량순으로 조회하시오. ```sqlSELECT 브랜드, 종류, 가격 FROM COFFEELISTWHERE 브랜드 = &apos;스타벅스&apos; AND 가격 &lt;=5000 AND 용량 &gt;=200;``` ### 문자유형 비교방법 **CHAR VS CHAR**- 길이가 다른 CHAR은 작은쪽에 SPACE추가하여 비교- 서로 다른 문자가 나올때 까지 비교- 달라진 첫 문자의 값에 따라 크기 결정- BLANK 수만 다르면 서로 같은 값으로 결정**VARCHAR2 VS CHAR**- 서로다른 문자가 나올때까지 비교- 길이다 다르면 짧은것이 끝날때까지만 비교 후 길이가 긴 것이 긴것으로 결정- 길이가 같고 같은것이 없으면 같은것으로 결정- VARCHAR2는 NOT NULL까지 길이를 말함(?)**NUMVER VS 문자열**- 상수를 변수 타입과 동일하겨 변경 후 비교- 변수쪽이 CHAR 유형 타입이면 CAHR VS CHAR 적용- 변수쪽이 VARCHAR2유형 타입이면 VARCHAR2 VS CHAR 적용 ## 3. SQL 연산자- 모든 데이터 타입에 적용가능한 연산자 소개 ### IN(a,b,c) 연산자- ()안에든 조건 중 하나와 일치하면 참 예제1) COFFEELIST 테이블에서 브랜드가 스타벅스, 커피빈, 이디아인 데이터를 모두 조회하시오. ```sqlSELECT * FROM COFFEELISTWHERE 브랜드 IN(&apos;스타벅스&apos;, &apos;커피빈&apos;, &apos;이디아&apos;);``` 예제2) COFFEELIST 테이블에서 브랜드가 스타벅스이면서 가격이 5000원 이거나, 브랜드가 이디아이면서 가격이 3000원인 커피 데이터를 모두 조회 하시오. * 결과 데이터 : 스벅 5000원커피 , 이디아 3000원 커피 ```sqlSELECT * FROM COFFEELISTWHERE (브랜드, 가격) IN((&apos;스타벅스&apos;,5000),(&apos;이디아&apos;, 3000));``` 예제3) COFFEELIST 테이블에서 브랜드가 스타벅스이거나 이디아이고, 가격이 5000원이거나 3000원인 데이터를 모두 조회하시오. (예제2번과 결과가 다르다 비교하길) * 결과 데이터 : 스벅 5000원 커피, 스벅 3000원커피, 이디아 5000원 커피, 이디아 3000원 커피 ```sqlSELECT * FROM COFFEELISTWHERE 브랜드 IN(&apos;스타벅스&apos;,&apos;이디아&apos;) OR 가격 IN(5000, 3000);``` ### LIKE 연산자- %는 아무 데이터나 다 받음- _는 한표시당 한 글자만 받음 예제) COFFEELSIST테이블에서 종업원 성이 김 씨인 커피점 조회하시오. ```sqlSELECT * FROM COFFEELISTWHERE 종업원 LIKE &apos;김%&apos;;``` ### BETWEEN a AND b 연산자 예제) COFFEELIST테이블에서 가격이 3000에서 5000원인 데이터 조회. * 결과값 : 커피가격이 3000원이상 5000원이하인 커피 데이터 리스트 ```sqlSELECT * FROM COFFEELISTWHERE 가격 BETWEEN 3000 AND 5000;``` ### IS NULL 연산자- NULL 과 수치 연산은 NULL값 리턴- NULL과 비교연산은 FALSE리턴- 특정값과 비교할 수 없고 크기 비교 불가 ```sqlSELECT * FROM COFFEELISTWHERE 브랜드 = NULL;--결과값 : 선택된 레고드가 없음. (브랜드 = NULL)이 FALSE이기 때문SELECT * FROM COFFEELISTWHERE 브랜드 IS NULL;--결과값 : 브랜드칼럼에 NULL이 들어가있는 데이터 조회``` ## 4. 논리연산자### AND 해당되는 조건이 모두 참이어야 참### OR 앞뒤의 조건 중 하나라도 참이면 참### NOT뒤에오는 조건과 반대되는 결과 리턴- 연산자의 우선순위 (), NOT, AND, OR 순서이므로 ()를 적절히 사용하여 원하는 조건을 형성해야함 ## 5. 부정연산자### 논리부정연산자### 부정 SQL연산자 ## 6. ROWNUM### ROWUNUM- 임시로 부여되는 행 번호- 테이블에서 원하는 행만 가져올때 WHERE절에서 행의 개수를 제한하는 목적으로 사용```sql--1행만 가져올때SELECT * FROM COFFEELIST WHERE ROWNUM=1;SELECT * FROM COFFEELIST WHERE ROWNUM&lt;=1;SELECT * FROM COFFEELIST WHERE ROWNUM&lt;2;--2행 이상 가져올때SELECT * FROM COFFEELIST WHERE ROWNUM&lt;=3;SELECT * FROM COFFEELIST WHERE ROWNUM=3;--이건 사용불가(무조건 1행부터 데이터를 가져오기때문)--고유한 키나 인덱스로 활용가능UPDATE MY_TABLE SET COLUMN1 = ROWNNUM;","link":"/2019/04/13/tec/sql/sql4/"},{"title":"[DAY 1] 첫 오로라","text":"거의 20시간 넘게 비행기를 타고 숙소에 도착했다.첫번째 식사는 김치찌개.밤이 되었다.첫날 밤을 그냥 자고싶진 않았다.아픈 언니와 피곤한 아빠를 뒤로하고 엄마랑 그로타 등대로 향했다.기대가 크면 실망이 클까봐 기대를 꾹꾹 눌렀다.등대를 향하는 바닷가도로 위 푸른 구름이 보였다.이거 오로라 아냐?사진을 찍어보는데 흥분을 가라앉히기 힘들었다.결국 등대 가기전 불빛이 없는 공터에 차를 대고 내렸다.그냥 막 흥분이되었었다.카메라로 어떻게 찍는지 연습을 못해서…아쉽게 사진은 제대로 찍지 못하였다.눈으로 담아도 충분했다고 생각했다.(이때는ㅜㅜ)가족들이 다 오지 못한게 아쉬워 숙소로 돌아가 아빠를 모시고 왔지만아빠는 오로라 흔적만 보셨다.오로라 없는 겨울 밤하늘도 예뻤다.첫 오로라는 성공적이였다.","link":"/2019/03/10/trip/europ/iceland2/"},{"title":"[DAY 8] 아쿠레이리도시 구경하기- 쇼핑","text":"수영을 마치고 운전으로 고생하신 아빠는 쉬러 숙소에 가셨다.우리 세 모녀는 도시를 구경했다.숙소 옆 루터 성당이다..도시 구경을 마치고 쇼핑몰 센터에 갔다.눈이 발목까지 쌓이고 계속 왔다.도시는 아기자기한 가게 들이 많았다.옷같은것도 팔고 했는데 딱히 맘에 드는 옷들은 없었다.여기는 특산품이 따로 없어서 그냥 구경만 많이하고엄마 친구들 기념품 사고 저녁 먹을거랑 간식이랑 샀다. 숙소에 돌아와보니 주차 위반 딱지를 뗐다ㅠㅠ","link":"/2019/03/29/trip/europ/iceland21/"},{"title":"[DAY 5] 하얀 집 - 에이일스타디르","text":"또다시 두시간 정도 달려 에이일스타디르에 도착했다.디위피보귀르에서 직선 거리는 멀지 않은데 해안선을 따라 달리느라 오래 걸렸다.오늘은 관광 코스가 없다고 그랬었는데해안선을 따라 달리는 풍경이 너무나 좋았다.하루종일 운전하는 아빠는 힘드셨을듯..바람이 세지고 어두워지니 낭떠러지 같은 해안가 도로가 굉장히 위험했다.드디어 숙소 도착.도시에 거의 다 와서 눈이 굉장히 많이 내렸다.무릎까지 순식간에 쌓였다.숙소 문이 잠겨있어 친절한 주인 아져씨가 와서 문을 열어주고 갔다.아저씨가 날씨가 안 좋아서 하루 더 지내게 되면 방을 알아봐준다고 했다.여기서 하루 더 보낼수도 있겠다 싶었다. 여태 지냈던 방중에 가장 넓고 좋았다.부얶도 크고 깨끗했고. 식자재료도 많이있었다.가장 중요했던 세탁기가 있어서 그동안 밀렸던 빨래를 몰아서 했다.","link":"/2019/03/23/trip/europ/iceland15/"},{"title":"[DAY 6] 데티포스","text":"날씨나 도로사정때문에 겨울에는 보기 힘들다는 데티포스를 가기로 했다.하필 이런 눈내리는 날씨에.아이슬란드는 겨울에 눈때문에 도로가 통제되는 일이 빈번하여도로상황을 보는 앱을 항상 보면서 다녔다. 초록색은 clear 1단계.빨간색은 impassable 8단계.북쪽의 도로는 대부분 주황색, spots of ice, 하늘색 slippery 상태였다.데티포스를 향하는 길은 핑크 땡땡이.dif.driving 6단계 이었다.4륜 구동차는 다닐수 있다고 공지되어 있어 우리는 가보기로 했다.처음 들어가는 길은 신났다.모험심이 넘쳤고 스릴 있었다.한 10분쯤 들어갔을까. 갑자기 눈이 쏟아지며 가시거리가 좁아졌다.1미터 앞도 거의 안 보이는데다가 눈이 너무 쌓여 폭포를 포기하고 돌아나오기로 했다.도로에는 우리 차 밖에 없었다.차를 돌리는데 바퀴가 헛돌았다.여행 처음으로 사고의 위험을 느꼈다. 다같이 내려서 차를 밀고 겨우 돌렸다.한창 차가 눈에 빠져서 끙끙댈 때 다른 차가 들어왔다.우리 차를 보더니 곧 돌려서 나갔다.그 차가 낸 눈길을 따라 천천히 왔던 길을 되돌아 나갔다. 겨우 1번도로로 탈출할 수 있었다.빨리 숙소로 가서 쉬고 싶었다.우리의 시련은 이게 시작이었다…","link":"/2019/03/25/trip/europ/iceland17/"},{"title":"[DAY 9] 월터의 현실은 상상이된다 카페","text":"아쿠레이리의 2박3일을 마치고 아이슬란드 수도 레이캬비크에 가는 날이다.가는 길에 월터의 현실은 상상이 된다에 나왔던 파파존스건물에 가보기로 했다.지금은 파파존스가 아니라 카페로 바꼈다. 아이슬란드에서 첫 외식.커피 종류와 빵을 샀다.몇개 안 샀는데 되게 비싸다ㅠㅠ카페 전망이 완전 좋다.","link":"/2019/04/01/trip/europ/iceland23/"},{"title":"[SQL] 함수","text":"1. 문자열 함수LOWER(문자열) 문자열 소문자로 변경 UPPER(문자열) 문자열 대문자로 변경ASCII(문자) 문자, 숫자를 ASCII로 변경CONCAT(문자열1, 문자열2) 문자열1과 문자열 2 합침(||와 같은 기능)SUBSTR(문자열, M [,N]) 문자열 중에 M부터 N개의 문자 리턴(N이 없으면 M부터 끝까지 리턴) LENGTH(문자열) 문자열 개수 리턴LTRIM(문자열 [,지정문자]) 문자열의 첫 문자부터 지정문자를 제거함(지정문자 생략시 “”공백 제거)RTRIM(문자열 [,지정문자]) 문자열 제일 마지막부터 지정문자를 제거함(지정문자 생략시 “”공백제거)TRIM(지정문자 FROM 문자열) 문자열의 양끝의 지정문자 제거 2. 숫자형 함수ABS(숫자) 숫자의 절대값 리턴SING(숫자) 숫자의 양수, 음수, 0을 구분(결과값 -1 OR 0 OR 1)MOD(숫자1, 숫자2) 숫자1/숫자2의 나머지 리턴CEIL(숫자) 숫자보다 크거나 같은 최소 정수리턴FLOOR(숫자) 숫자봗 작거나 같은 최대정수리턴ROUND(숫자 [,M]) 숫자를 M+1자리에서 반올림해서 리턴(M의 DEFAULT는 0)TRUNC(숫자[,M]) 숫자를 M+1자리에서 버림해서 리턴(M의 DEFAULT는0)EXP(),POWER(),SQRT(),LOG() 지수, 거듭제곱, 제곱근, 로그값 리턴 3. 날짜형 함수SYSDATE 현재 날짜, 시각 출력EXTRACT(‘YEAR’ FROM d) d 날짜에서 ‘YEAR’(년) 추출(YEAR에 MONTY, DAY 입력가능)TO_NUMBER(TO_CHAR(D,’YYYY’)) 날짜데이터에서 년도 출력TO_NUMBER(TO_CHAR(D,’MM’)) 날짜데이터에서 월도 출력TO_NUMBER(TO_CHAR(D,’DD’)) 날짜데이터에서 일 출력 4. 변환형 함수TO_NUMBER(문자열) 문자열을 숫자로 변환TO_CHAR(숫자|날짜 [,FOMAT]) 숫자나 날짜를 주어진 포맷형태로 문자열 타입으로 변환TO_DATE(문자열[,FOMAT]) 문자열을 주어진 포맷 형태로 날짜타입으로 변환 5.CASE표현함수의 성질을 가지고 있어 중첨해서 사용할 수 있음1234CASE SIMPLE_CASE_EXPRESSION 조건 ESLE 표현절END 예제) 1234567891011121314151617--예제1SELECT ENAME, CASE WHEN SAL&gt;2000 THEN SAL ELSE 2000 END REVISED_SALARYFROM EMP;--예제2)SELECT LOC, CASE LOC WHEN 'NEW YORK' THEN 'EAST' WHEN 'CHICAGO' THEN 'CENTER' ELSE 'ETC' END AS AREAFROM DEPT; 6.NULL관련함수연산NULL+숫자=NULL;(사칙연산 모두 포함)NULL+문자열=NULL; NVL(표현식1, 표현식2) 표현식 1 이NULL이면 표현식 2를 출력(두 표현식의 데이터 타입이 같아야함)NULLIF(표현식1, 표현식2) 표현식1이 표현식2와 같으면 NULL, 아니면 표현식1 출력COALESCE(표현식1,..,표현식N) 임의의 개수 표현식에서 NULL이 아닌 최초의 표현식 리턴, 모든 표현식이 NULL이면 NULLD을 리턴NULL과 공집합테이블 안에 값이 NULL이면 NULL, 테이블 이 선택안되면 공집합공집합을 NULL로 바꾸기 위해 적절한 함수 사용 EX)MAX() NULLIF1234--사원 테이블에서 MGR과 7698이 같으면 NULL, 다르면 MGR 표시하라. SELECT ENAME, EMPNO, MGR, NULLIF(MGR, 7698) NUIFFROM EMP; COALESCE12345678910111213141516--사원테이블에서 커미션을 1차선택값, 급여를 2차 선택값으로 선택하되 --두 칼럼 모두 NULL이면 NULL로 표시SELECT ENAME, COMM, SAL, COALESCE(COMM, SAL) COALFROM EMP;--다른방법SELECT ENAME, COMM, SAL CASE WHEN COMM IS NOT NULL THEN COMM ELSE (CASE WHEN SAL IS NOT NULL THEN SAL ELSE NULL END) END COALFROM EMP;","link":"/2019/04/14/tec/sql/sql5/"},{"title":"[DAY 11] 골든서클 - 싱벨리어 국립공원","text":"여행 둘째날 못간 싱벨리어 국립공원에 다시 가보기로 했다.오늘은 날씨가 너무 좋았다. 여기는 두개의 지각판이 만나는 곳이다.물이 너무 맑아서 깊이가 가늠이 안 된다고 했다.사람들이 동전을 던져놨는데 빤작빤작 이뻤다.공원 나무에 눈꽃이 내려 앉았다.눈도 치우지 않은 구간에는 저렇게 많이 쌓여있었다.미바튼에서 놀지 못한 한을 여기서 조금이나마? 풀었다.스노쿨링 장비를 한 사람들이 지나간다는 표지판스노쿨링을 투어가 몸무게 제한이 있어서 아쉽게 못했다..물에 비친 하늘이 너무 이뻣다.해를 중심으로 원을 그린 무지개도 봤었다.","link":"/2019/04/03/trip/europ/iceland26/"},{"title":"[DAY 7] 극적으로 미바튼 탈출하기","text":"아침이 되었다.눈은 더 많이 내렸다.전날 눈때문에 많이 고생했던 우리는 빨리 미바튼을 떠나고 싶었다.점심 도시락을 싸고 출발하려는데 눈이 너무 많이와서 도저히 차에까지 갈 수 없었다.고립되었다ㅠㅠ아무래도 금방 출발하기는 힘들 것 같아 커피와 음식을 가질러 차에 가기로 했다.차에 가는것도 너무 힘들었다.눈이 너무 많이 와서 얼굴을 때리고, 지형을 몰라서 몸이 푹푹 눈속에 파묻혔다. 나는 결국 차에 올라가는것을 실패하고 엄빠만 다녀오셨다.친절한 숙소 호스트가 추가 요금 없이 숙소에서 지내게 해주었다. 점심시간이 다 되어도 눈이 그칠 기미가 안 보였다.싸놓은 도시락을 먹었다.자는것 밖에는 할일이 없었다.사실 이런 눈은 경험하기 힘들어서 밖에 나가서 눈에 파묻히기 놀이하면 좋았을텐데ㅠㅠ라는 생각이 한국에서 들었다. 세시? 네시쯤 드디어 눈이 조금 잦아들고 바람이 너무 거세 도로 위의 눈을 다 날려버렸다.우리는 눈이 더내리기 전에 첩보 영화처럼 캐리어를 들고 눈위를 막 뛰었다.웃음이 나왔다.차에 겨우겨우 도착한 후 엉금엉금 기어서 겨우 1번 메인로드에 도착했다.메인도로를 채10분도 달리지 않았을때 눈에 처박힌 차를 볼 수 있었다. 일몰시간이 다 되서야 우리는 제2의 도시 아쿠레이리로 출발할 수 있었다.사실 미바튼에서 아쿠레이리 가는길목에 폭포가 하나 더 있는데 구경할 새도 없이 빨리 이동했다.해가 다 지고 숙소에 도착했다.눈이 역시 많았지만 사람들도 많았기에 굉장히 안도했다.늦은 저녁을 먹고 푹 쉬었다. 내일은 도시구경을 다닐 예정이다.","link":"/2019/03/27/trip/europ/iceland19/"},{"title":"[DAY 11] 마지막 쇼핑데이!","text":"심벨리어 국립공원산책?을 마치고 큰 쇼핑센터에 쇼핑하러 갔다.꽤 넓고 구경하고 선물들을 조금 샀다.장소를 옮겨 크로난 마트에 왔다.크로난은 유기농? 싱싱한 식료품을 많이 가지고 있는 곳이라고 했다.","link":"/2019/04/03/trip/europ/iceland27/"},{"title":"[DAY 8] 아쿠레이리에서 수영하기","text":"큰 도시에 와서 맘 편히 휴식을 취하기로 했다.아이슬란드는 수영장이 유명한데 숙소 근처에 수영장이 있어 가보기로 했다.여태 지냈던 도시들은 다 작은 마을이었는데 여기는 되게 컸다. 수영장에 도착했다.공용 샤워장에서 어린 아이슬란드 꼬맹이들이 황인종 처음 봣는지 넘 신기 하게 처다보더라..옷을 갈아입고 밖에 야외로 나가니까 눈은 여전히 많이 내렸다.수영장 물온도와 날씨 차이 때문에 물안개가 껴서 포근한 느낌이 들었다.아침이라 그런지 사람들도 많이없었고, 관광객들은 우리 가족뿐인것 같았다.눈 맞으면서 수영하니까 재밌었다. 신나게 수영하고 한 서너군데 온천 물이 있어서 추우면 거기서 몸을 녹였다.너무 추워서 물 밖을 나갈때는 후다닥 이동했다.미끄럼틀도 있었는데 잠깐 운영하는 시간이 있어 울 가족들만 신나게 탔다.현지인들은 자주와서 재미 없나보다.ㅎㅎ","link":"/2019/03/28/trip/europ/iceland20/"},{"title":"[DAY 2] 골든서클-게이시르","text":"아이슬란드 대표 관광지 골든서클 투어를 하기로 했다.첫번째 게이시르.예전에 옐로우스톤국립공원에서 간헐천을 보면서 가족들 생각이 많이났는데여기서 같이 볼수 있어서 정말 기뻤다.지구가 방구뀌는곳 생각보다 냄새는 많이 안 났고 분출도 자주 있었다.나는 고프로를 들고다니며 동영상을 찍었는데아빠가 카메라 의식을 너무 많이한다.","link":"/2019/03/11/trip/europ/iceland3/"},{"title":"[DAY 13] 아이슬란드에서-헬싱키-한국으로","text":"아침 일찍 일어나 조식을 먹고 (새벽 4신가?) 셔틀을 타고 공항에 갔다.인건비가 비싸서 직원이 없어 셀프 체크인을 했다.짐까지 스스로 붙이는건 처음이었다.어찌저찌 비행기를 타고 자고 일어나니 커피를 줬다.밖이 밝아졌다.노르웨이 헬싱키에서(맞나?) 환승을 하려고 내렸다.여기서 점심을 먹었다.화페 단위를 몰라 쩔쩔맸다.무민샵에서 기념품을 사고 구경을 했다.귀여운게 완전 많아.우리 엄마가 점심때 좀 삐져서 따로 우동을 드셨다.엄마 미안 ㅎㅎ드디어 인천공항에 도착했다.영화를 한 두편은 본 것 같다.스위치도 좀 하구한국에서 출국할 때 언니가 노트북을 공항에서 잃어버렸는데무사히 분실물 센터에서 찾았다.이제 진짜 집에 간다.","link":"/2019/04/06/trip/europ/iceland30/"},{"title":"[DAY 5] 요쿨살론-빙하호수","text":"빙하가 떠내려온 호수인 요쿨살론에 도착했다.오로라 뷰 포인트라던데 우리는 이른 아침에 도착했다.사실 해가 짧아서 새벽도 아닌데 어스름 했다.얼음을 너무 좋아하는 내가 빙하를 먹어 볼 수 있다니!!미리 잔에 음료수를 담아가서 빙하를 넣어서 먹었다.빙하는 엄청압축되었던지 시간이 꽤 오래지나도 형태를 유지했다.여기에 정신이 팔려서 다이아몬드 비치에 못 갈뻔했다.못갔으면 너무 아쉬웠을듯.","link":"/2019/03/20/trip/europ/iceland12/"},{"title":"[DAY 2] 헬라(Hella)-통나무집","text":"골든서클 투어중 싱벨리어 국립공원을 이때 못갔다.차 드라이브한게 국립공원을 다 둘러본거라고 생각했다.골든서클 투어를 마치고 근처 작은 마을인 헬라에서 묶었다.숙소 가는 길 핑크핓 하늘에 엄마가 너무 좋아하셨다.숙소뒤에 강가와 노을을 감상했다.마트에서 장을 처음 보고 저녁을 먹은 후 쉬었다.오두막집의 나무 향이 너무 좋았다.언니가 호들갑을 떨며 깨웠는데.숙소밖에서 오로라가 보였다.당장 모든 식구들을 깨워 밖으로 나갔다.아빠언니에겐 첫번째, 엄마와 나에겐 두번째 오로라였다.","link":"/2019/03/13/trip/europ/iceland5/"},{"title":"[DAY 3] 셀애란즈포스 폭포","text":"벌써 세째날 아침.셀야란즈포스에서 멈춰섰다.링로드 1번도로에서 폭포가 멀리서 보여 찾기 쉬웠다.입장료는 없지만 주차비가 있다. 하루에 7천원정도였나.잠깐들러 사진만 찍고 가기에는 조금은 아까웠다.여름엔 폭포 뒤로 들어가볼 수도 있다고 했는데겨울이라 막혀있엇다.아쉽..맑은날에는 쌍문지개도 보인다고한다.조금은 우중충한 날씨. 춥진 않았다.","link":"/2019/03/14/trip/europ/iceland6/"},{"title":"[DAY 3] 레이니스피아라","text":"폭포를 보고 검은모래 해변을 보러왔다.아빠가 무려 2천원짜리 화장실에 다녀왔다.여긴 신기하게 바닷가 특유 비릿한 냄새가 안 난다.파도와 바람이 거세어 사진찍다 사고를 당한 사람이 많다고 조심하란다.아이슬란드에서 사고가 자주 일어나니 조심히 다녀야겠다.주상절리도 보고 나름 섬 국가인데 바다에 처음 왔다.해가 지는걸 보니 이제 숙소로 돌아가야 된다.숙소잡는데 애를 좀 먹었지만 너무 좋았다.","link":"/2019/03/16/trip/europ/iceland8/"},{"title":"[DAY 3] 스코가포스 폭포","text":"셀야란즈포스에서 조금 더 지나면 스코가포스 폭포가 나온다.조금 더 컸다.스코카포스 폭포는 폭포위로 올라가볼 수 있다.발이 아픈 언니를 빼고 가족들은 계단을 걸어 올라갔다.위에서 내려다 보는 폭포도 멋졌고 올라가니 수평선이 보였다.설산봉우리가 작은 스위스 같아 보이기도 했다.언니는 못 올라와서 아쉬웠겠다.폭포 근처라 계단에 얼음이 많아 오르고 내릴때 아주 위험했다.우리 가족은 아이젠을 신었지만 그래도 조심.특히 내려갈때 미끄러지는 사람들을 많이 봤다.나는 그냥 계단 옆길에 얼음 빙판길에 미끄럼틀을 타기로 했다.엄청 금방 안전하게 내려왔다.ㅎㅎ","link":"/2019/03/15/trip/europ/iceland7/"},{"title":"[DAY 3] 스노우볼 달쇼프디 게스트하우스","text":"이동시간이 길어서 어느덧 해가 져버렸다.점점 눈이 많아졌다. 깜깜해졌다.까만 세상속에 마을 불빛이 혼자 깜박였다.그 불빛이 없었으면 너무 무서웠을것 같다.잘 보이지도 않는 눈길을 조심히 달려 겨우 숙소에 도착했다.숙소빼고 주변에 건물이 세채 밖에 없었다.정말 동화속 같았다.주변이 모두 평지여서 여기서 오로라와 별을 보고싶었지만,구름이 잔뜩있었다.우리는 숙소가 너무 마음에 들어 하루를 조금 쉬어가기로 했다.오랜만에 늦잠자고, 조식을 즐기기로 했다. 다음날새벽에 깨서 혼자 산책을 나갔다.온통 눈밭에 하늘도 구름에 어스름한 안개까지 정말 스노우 볼 속에 있는 기분이었다.해가 뜨자 아쉽게 그 분위기는 사라졌지만 동화속 풍경은 여전했다.아마 가족들도 모두 이번 여행에서 가장 기억에 남는 숙소가 아니었을까.여름에 다시 오고싶은 숙소 중에 하나다.","link":"/2019/03/17/trip/europ/iceland9/"},{"title":"[DAY 10] 할그림스키르캬","text":"아침에 레이캬비크의 상징 할그림스키르캬에 갔다.10:30분쯤인가서 오르간 연주 하는것을 감상했다.전망대에 올라갔다.전망대는 정말 별거 없었다.그냥 회색 시멘트에 창문이 하나 있고 발판 하나 띡. 창문밖으로 보이는 풍경이 좋았다.알록달록한 집들이 옹기종기 모여있었다. 점심은 아슬 두번째 외식으로 유명한 핫도그 집에 갔다.사실 비싸기만하고 크게 맛이 있어보이진 않았지만 여기까지 와서 안먹을 수도 없었다. 그다음은 주말 벼룩시장에 갔다.주말시장 가는 길에 오리랑 백조.주말 벼룩시장을 보려고 일부러 날짜를 맞춰서 왔었다.책 옷, 초콜릿 등을 팔고 있었는데 딱히 사고싶은 물건은 없었다. 쇼핑을 마치고 저녁 먹고수영장에 또 갔다.여기는 수영장 내부는 사진을 찍을 수 없엇다.따듯한 곳에는 사람이 너무 많고 미끄럼틀도 탈수 없어서 좀 아쉬웠다.","link":"/2019/04/02/trip/europ/iceland25/"},{"title":"[2014.08.] 미국 옐로우스톤 1","text":"금요일 오전수업을 마치고 하나 듣고 3박4일간의 옐로우스톤으로 향하는 길을 떠났다.옐로우스톤은 미국에서 가장 오래된 국립공원으로 학교에서 차로 대략 6시간걸릴 예정이다.. 쭉 뻗은 길, 각자 취향의 노래, 간식, 평화로운 풍경에 첫 여행이라는 설렘까지, 정말 신이났다.드라이브 길 풍경은 아무리 보아도 질리지 않을것 같다.운전만 잘하면 나도 저 쭉 뻗은 도로 운전해보고 싶었다.구글맵으로 길을 찾았는데 미국은 정말 운전하기 쉬운 것 같다. 중간 화장실을 가기위해 마트에 들렀다. 간식도 간단히 산것 같은데 기억이 안난다. 잠깐 화장실만 갔다 온것 같은데 벌써 해가 떨어지고 있다. 오랜 시간운전자들 넘 고생한다. 차 뒷좌석 가운데 앉은 내 엉덩이 허리도 엄청 수고했다. 하지만 아직 갈길이 멀다. 같은 음악을 몇번을 반복해서 들었는지 다 외우고 질릴 정도. 차라리 아직 더 가야한다. 해지는 석양도 정말 멋있긴하다.밤이 되고 있다. 가로등이 하나 없는 차도를 헤드라이터에 의지해 달리고 있다. 점점 잠이오지만 운전자들의 잠을 깨주기위해 교대로 대화를 나눈다. 한번 더 쉴때가 온것 같다. 잠깐 주유소에 들렀다.오랜만에 편 허리때문인지 걸어오는 발걸음이 아주 신났다. 이제 숙소가 얼마 안남아서 더 힘이 솟는것 같다.드디어 숙소에 도착했다.어두운데 비슷한 숙소가 여러개라 처음에 다른 숙소에 들어갈뻔했다. 미국은 인건비가 비싸서인지 밤에 체크인을 하면 사람은 없고 숙박객이 숨김통 같은곳에 열쇠를 숨겨놓고 알아서 찾아 들어가야한다.넘 피곤해서 도착때 사진이 없는듯. 옐로우스톤은 보지도 못했는데 벌써 여행의 하루가 지났다.하지만 학교에서 챙겨온 라면과 아인슈타인 베이글로 아침을 먹고 드디어 국립공원으로 향한다.","link":"/2019/02/01/trip/n.america/ws1/"},{"title":"[DAY 12] 블루라군 with 옐로우스톰 경보","text":"여행 마지막을 앞두고 있는데 옐로우스톰 경보가 발생했다.초속 20미터가 넘는 바람이 불었다.오늘은 블루라군 온천을 예약해놨었는데사람이 정상적으로 걷기는 힘든 바람세기여서 걱정이 됐다.호텔 직원한테 물어보니 너무나 태연하게 괜찮다고 말을 해서 그나마 다행이었다. 블루라군이 2시에 예약 되어있어 아침에 은행을 들러 이쿠레이리에서 끊은 주차위반 벌금을 내러 갔다.3일 이낸가 벌금을 내면 30%할인해준다.만약 벌금을 내지 않고 귀국하면 렌트카에서 내주고 수수료를 붙여 보증금에서 제외한다.은행에 가니 커피를 뽑아 먹을 수 있어서 커피를 내려 마셨다.벌금이 2만원인가 그랬는데 커피값으로 퉁친것 같다. 블루라군 가는길에 이끼 군락이 있어서 잠깐 내려봤다.나는 거의 바람에 날아갈 뻔했다.엄마가 진지하게 나 날아갈까봐 꼭 붙드셨다ㅋㅋ 블루라군에 가니 하늘색 물색이 너무 이뻤다.처음에 아빠를 잃어버려 갈등이 좀 있었지만 곧 상봉했다.티켓값에 포함된 음료를 하나씩 들고 온천을 즐겼다. 샌드위치랑 코코아를 마셨다.싱싱해서 맛잇었는데 저거 하나가 만원이 넘었다. 팩을 하고 실컷 놀고 숙소로 다시 돌아왔다. 여기까지가 우리의 마지막 아이슬란드 일정이었다.","link":"/2019/04/04/trip/europ/iceland28/"},{"title":"[DAY 12] B&B Hotel 마지막 밤","text":"블루라군에서 실컷 놀고 조심히 숙소로 돌아왔다.렌트카를 반납하러 갔다.렌트카 반납할때 트집 잡아서 비싸게 물어달라는 업체가 있다고 해서두근두근했지만 생각보다 휙~후레쉬로 대충 비춰보고 ok해줬다.걱정했던 일까지 잘 마무리 되니까 이제서야 한시름 놓았다.업체에서 친절하게 숙소로 데려다 주고숙소에서 우리는 마지막 만찬을 먹었다.한국에서 음식을 많이 싸갔는데 좀 남았다.아깝지만 먹고 남은건 정리하고 잠자리에 들었다. 공항 근처에 있는 호텔로 공항까지 셔틀로 데려다 준다.새벽일찍 출발한다.","link":"/2019/04/05/trip/europ/iceland29/"},{"title":"[DAY 9] 아이슬란드 수도, 레이캬비크","text":"북쪽에서 남쪽으로 향할수록 확실히 눈이 줄어들고 있었다. 한참 길을 달려 도시에 도착하니 이번 여행에서 봤던 차들보다 훨씬 많은 차들이 도로에 있었다. 이번 숙소는 노란 예쁜집이었다.방음이 좀 안되긴 했지만 깔끔하고 좋았다.","link":"/2019/04/01/trip/europ/iceland24/"},{"title":"[DAY 8] 아쿠레이리도시 2박3일 숙소","text":"여기서 하루 더 머물기로 했다.숙소는 아파트형태로 방 2개 거실 부엌 세탁기가 있었다.깔끔해서 편하게 지냈던것 같다.엄마가 둘째날 저녁 요리하다가 화재 경보기를 울렸다.해외에서 요란한 소리가 나니 너무 놀랐다.다행히 큰 소란 없이 잘 마무리 되었다.","link":"/2019/03/30/trip/europ/iceland22/"},{"title":"[DAY 2] 골든서클-굴포스","text":"굴포스 폭포로 향했다.여기는 바람이 너무 세다고 유명했던덴데우리가 갔을때는 너무나 맑고 바람이 많이 안 불었다.덕분에 폭포 소리가 정말 잘 들렸다.맑은 날씨 덕분에 무지개도 볼 수 있었다.자연속에서 이렇게 즐길 수 있는것도 행운이었다.여긴 화장실이 유료였던것 같다.","link":"/2019/03/12/trip/europ/iceland4/"},{"title":"[CH11. 컬렉션프레임웍과 유용한 클래스] List, Set, Map","text":"1. 컬렉션 프레임웍(Collection Framework)데이터군을 저장하는 클래스들을 표준화 한 설계. 1.1 컬렉션프레임웍의 핵심 인터페이스 - List, Set, Map 인터페이스 특징 List 순서가 있는 데이터의 집합. 데이터의 중복을 허용한다. 예) 대기자 명단 구현클래스: ArrayList, LinkedList, Stack, Vector 등 Set 순서를 유지하지 않는 데이터의 집합. 데이터의 중복을 허용하지 않는다. 예) 양의 정수집합, 소수의 집합 구현클래스 : HashSet, ThreeSet 등 Map 키(key)와 값(value)의 쌍(pair)으로 이루어진 데이터의 집합 순서는 유지되지 않으며, 키는 중복을 허용하지 않고 값은 중복을 허용한다.예) 우편번호, 지역번호(전화번호)구현클래스: HashMap, ThreeMap, Hashtable, Properties 등 1.1.1 Collection 인터페이스 메서드 설명 boolean add(Object o)boolean addAll(Collection o) 지정된 객체 또는 컬렉션이 객체들을 Collection 에 추가한다. void clear() Collection 의 객체를 모두 삭제한다. boolean contains(Object o)boolean containsAll(Collection c) 지정된 객체 또는 Collection의 객체들이 Collection에 포함되어 있는지 확인한다. boolean equals(Object o) 동일한 Collection인지 비교한다. int hashCode() Collection의 hash code를 반환한다. boolean isEmpty() Collection이 비어있는지 확인한다. Iterator iterator() Collection의 Iterator를 얻어서 반환한다 boolean remove(Object o) 지정된 객체를 삭제한다 boolean removeAll(Collection c) 지정된 Collection에 포함된 객체들을 삭제한다. boolean retainAll(Collection c) 지정된 Collection에 포함된 객체만을 남기고 다른 객체들은 Collection에서 삭제한다. 이 작업으로 인해 Collection에 변화가 있으면 true없으면 false를 반환한다. int size() Collection에 저장된 객체의 개수를 반환한다. Object[] toArray() Collection에 저장된 객체를 객체배열(Object[])로 반환한다. Object[] toArray(Object[] a) 지정된 배열에 Collectiom의 객체를 저장해서 반환한다. 1.1.2 List인터페이스| 메서드 | 설명 || void add(int index, Object element) addAll(int index, Collection c) | 지정된 위치에 객체를 컬렉션에 포함된 객체들을 추가한다. || Object get(int index) | 지정된 위치에 있는 객체를 반환한다. || int indexOf(Object o) | 지정된 객체의 위치를 반환한다.(List의 첫번째 요소부터 순방향으로 찾는다.) || int lastIndexOf(Object o) | 지정된 객체의 위치를 반환한다. (List의 마지막 요소부터 역방향으로 찾는다.) || ListIterator listIterator() ListIterator listIterator(int index) | List의 객체에 접근할 수 있는 ListIterator를 반환한다. || Object remove(int index) | 지정된 위치에 있는 객체를 삭제하고 삭제된 객체를 반환한다. || Object set(int index, Object element) | 지졷왼 위치에 객체를 저장한다. || List subList(int fromIndex, int toIndex) | 지정된 범위에 있는 객체를 반환한다. | 1.1.3 Set인터페이스중복을 허용하지 않고 저장순서가 유지되지 않는 컬렉션 클래스를 구현하는데 사용됨. HashSet, ThreeSet등이 있음. 1.1.4 Map인터페이스 메서드 설명 void clear() Map의모든 객체를 삭제한다 boolean containsKey(Object Key) 지정된 key 객체와 일치하는 Map의 key 객체가 있는지 확인한다. boolean containsValue() 지정된 value객체와 일치하는 Map의 value객체가 있는지 확인한다. set entrySet() Map에 저장되어있는 key-value쌍을 Map.Entry타입의 객체로 저장한 Set으로 반환한다. boolean equals(Object o) 동일한 Map인지 비교한다 Object get(Object key) 지정한 key 객체에 대응하는 value 객체를 찾아서 반환한다. int hashCode() 해시코드를 반환한다. boolean isEmpty() Map이 비어있는지 확인한다. Set keySet() Map에 저장된 모든 key 객체를 반환한다. Object put(Object key, Object value Map에 value객체를 key객체에 연결하여 저장한다. void putAll(Map t) 지정한 Map의 모든 key-value쌍을 추가한다. Object remove(Object key) 지정한 key객체와 일치하는 key-value 객체를 삭제한다 int size() Map에 저장된 key-value쌍의 개수를 반환한다. Collection values() Map에 저장된 모든 value객체를 반환한다. 1.1.5 Map.Entry 인터페이스1.2 동기화(Synchronization)Collections클래스에 아래와 같은 동기화 메서드 제공함. 필요할때 사용가능. 123456static Collection synchronizedCollection(Collection c)static List synchronizedList(List list)static Map synchronizedMap (Map m)static Set synchronizedSet(Set s)static SortedMap synchronizedSortedMap(SortedMap m)static SortedSet synchronizedSortedSet(SortedSet s) 위 메서드를 아래와 같이 사용가능함. 1List list = Collections.synchronizedList(New ArrayList(...)); 1.3 Vector와 ArrayList 공통점 차이점 - List인터페이스를 구현한다.저장순서가 유지되고 중복을 허용한다.- 데이터의 저장공간으로 배열을 사용한다. - Vector는 멀티쓰레드에 대한 동기화가 되어있으나 ArrayList는 그렇지 않다. Deep Copy vs Shallow Copy Shallow : 단순히 참조만 복사하는것, 원본 객체에 영향을 받는다.Deep : 원본과 같은 데이터를 저장하고 있는 새로운 객체나 배열을 생성하는것. 원본 객체에 영향을 받지 않음 1.4 LinkedList배열의 단점 크기를 변경할 수 없다. 비순차적인 데이터의 추가 또는 삭제에 시간이 많이 걸린다. LinkedList는 불연속적으로 존재하는 데이터를 서로 연결한것.링크드리스트의 각 요소(node)들은 자신과 연결된 다음 요소에 대한 참조(주소값)과 데이터로 구성됨. 1234class Node{ Node next; // 다음요소의 주소를 저장 Object obj; // 데이터를 저장} 이동방향이 단방향이어서 다음 요소에 대한 접근은 쉽지만 이전요소에 대한 접근은 어렵다.이 단점을 보완한것이 더블링크드리스트(이중 연렬리스트)링크드리스트에 참조변수를 하나 추가해서 이전 요소에 대한 참조가 가능하게 한것. 12345class Node{ Node next; //다음 요소의 주소를 저장 Node previous; //이전 요소의 주소를 저장 Object obj; // 데이터를 저장} 더블써큘러링크드 리스트두 있음. 순차적으로 추가/삭제하는 경우에는 ArrayList가 LinkedList보다 빠르다. 중간데이터를 추가/삭제하는 경우에는 LinkedList 가 ArrayList보다 빠르다. 데이터의 개수가 변하지 않는 경우는 ArrayList, 데이터 개수의 변경이 잦다면 LinkedList를 사용하는것이 낫다. 두가지 혼합 방법 : 처음작업전 데이터는 ArrayList에 저장, 작업할때는 LinkenList로 옮겨서 사용 123456789ArrayList al = new ArrayList(1000000);for(int i = 0; i &lt; 1000000; i++) { al.add(i+\"\");}LinkedList ll = new LinkedList(al);for(int i = 0; i &lt; 1000; i++) { al.add(500, \"X\");} 1.5 Stack과 Queue Stack은 마지막에 저장된 데이터를 가장 먼저 꺼냄 LIFO Queue는 처음에 저장한 데이터를 가장 먼저 꺼냄 FIFO Queue는 ArrayList보다 LinkedList로 구현하는것이 더 적합 Stack 메서드 설명 boolean empty() Stack이 비어있는지 알려준다 Object peek() Stack의 맨 위에 저장된 객체를 반환한다. 꺼내지는 않는다. 비어있으면 null을 반환한다. Object pop() Stack의 맨 위에 저장된 객체를 꺼낸다. Object push(Object item) Stack에 객체를 저장한다. int search(Object o) Stack에서 주어진 객체를 찾아서 그 위치를 반환한다.1부터 시작함 Queue 메서드 설명 Object element() 삭제없이 저장된 요소를 읽어온다. peek와 다른점은 queue가 비었을때 Exception을 발생시킴 boolean offer(Object o) Queue에 객체를 저장한다. 성공하면 true, 실패하면 false를 반환한다. Object peek() 삭제없이 읽어온다. Queue가 비었을때는 null을 반환한다. Object pool() Queue에서 꺼내온다. 비어있을때는 null을 반환한다. Object remove() Queue에서 꺼내온다. 비어있으면 에외를 발생시킨다. 스택의 활용 예 : 수식계산. 수식괄호검사, 워드프로세서의 undo/redo, 웹브라우저 앞으로 뒤로 큐의 활용 예 : 최근사용문서, 인쇄작업대기목록, 버퍼","link":"/2019/05/11/tec/java/java13/"},{"title":"[React] React 시작하기","text":"1. Nodejs 설치 및 최신 버전 확인(6버전 이상) https://nodejs.org/ko/ 여기서 최신 nodejs를 설치한다. 콘솔 창(window + R -&gt; cmd 검색) 에서 아래와 같이 명령어를 입력하면 내 pc에 깔린 nodejs버전이 나온다.1node -v 2. 프로젝트를 생성할 폴더 위치로 이동하여 다음과 같이 프로젝트를 시작한다.아래 명령어로 폴더에 이동후1cd d:\\dev\\react\\tutorial 아래 명령어로 프로젝트를 시작한다.12$ npm install -g create-react-app $ create-react-app my-app 3. my-app/src 하위의 파일들을 삭제한다.12$ cd my-app$ rm -f src/* 4. my-app/src/index.css 파일을 만들어 아래 내용을 복사한다.1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950body { font: 14px \"Century Gothic\", Futura, sans-serif; margin: 20px;}ol, ul { padding-left: 30px;}.board-row:after { clear: both; content: \"\"; display: table;}.status { margin-bottom: 10px;}.square { background: #fff; border: 1px solid #999; float: left; font-size: 24px; font-weight: bold; line-height: 34px; height: 34px; margin-right: -1px; margin-top: -1px; padding: 0; text-align: center; width: 34px;}.square:focus { outline: none;}.kbd-navigation .square:focus { background: #ddd;}.game { display: flex; flex-direction: row;}.game-info { margin-left: 20px;} 5. my-app/src/index.js 파일을 아래 내용을 복사하여 만든다.1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import React from 'react';import ReactDOM from 'react-dom';import './index.css'; class Square extends React.Component { render() { return ( &lt;button className=\"square\"&gt; {/* TODO */} &lt;/button&gt; ); }}class Board extends React.Component { renderSquare(i) { return &lt;Square /&gt;; } render() { const status = 'Next player: X'; return ( &lt;div&gt; &lt;div className=\"status\"&gt;{status}&lt;/div&gt; &lt;div className=\"board-row\"&gt; {this.renderSquare(0)} {this.renderSquare(1)} {this.renderSquare(2)} &lt;/div&gt; &lt;div className=\"board-row\"&gt; {this.renderSquare(3)} {this.renderSquare(4)} {this.renderSquare(5)} &lt;/div&gt; &lt;div className=\"board-row\"&gt; {this.renderSquare(6)} {this.renderSquare(7)} {this.renderSquare(8)} &lt;/div&gt; &lt;/div&gt; ); }}class Game extends React.Component { render() { return ( &lt;div className=\"game\"&gt; &lt;div className=\"game-board\"&gt; &lt;Board /&gt; &lt;/div&gt; &lt;div className=\"game-info\"&gt; &lt;div&gt;{/* status */}&lt;/div&gt; &lt;ol&gt;{/* TODO */}&lt;/ol&gt; &lt;/div&gt; &lt;/div&gt; ); }}// ========================================ReactDOM.render( &lt;Game /&gt;, document.getElementById('root')); 6. 아래 명령어로 시작한다.1234567891011121314151617181920$ npm start``` ## 7. localhost:3000 으로 아래와 같은 화면이 뜬다.## 8. my-app/src/index.js파일을 열어보면 아래 세가지 컴포넌트로 구성되어 있다.- Square : 하나의 &lt;button&gt;을 렌더링함- Board : 9개의 사각형을 랜더링함- Game : 공백있는 하나의 보드를 랜더링함## 9. Board 컴포넌트에서 Square 컴포넌트로 데이터(숫자 0~9) 전달하기### 9.1 index.js파일의 Board클래스 부분을 아래와 같이 변경한다.```jsclass Board extends React.Component { renderSquare(i) { return &lt;Square value={i} /&gt;; } 9.2 Square클래스 render 메서드를 아래와 같이 변경한다.123456789class Square extends React.Component { render() { return ( &lt;button className=\"square\"&gt; {this.props.value} &lt;/button&gt; ); }} 이렇게 변경해서 저장 후 npm start로 실행해보면 비어있던 9개 사각형 칸에 0~8까지 숫자가 입력되서 나온다. 10. 대화형 컴포넌트 : 빈 사각형을 클릭하면 X표시가 되게 변경하기10.1 Sqare의 render()함수를 아래와 같이 변경한다.Square클래스의 생성자에서 this.state을 설정하여 상태(초기값 null)를 가질 수 있게 한다.12345678class Square extends React.Component { constructor(props) { super(props); this.state = { value: null, }; }} 아래와 같이 render()함수를 변경하면 사각형을 클릭하면 클릭한 빈 사각형안의 값이 X로 바뀐다.1234567891011121314151617class Square extends React.Component { constructor(props) { super(props); this.state = { value: null, }; } render() { return ( &lt;button className=\"square\" onClick={() =&gt; this.setState({value: 'X'})}&gt; {this.state.value} &lt;/button&gt; ); }} 11 State에 저장하기클릭 할때마다 o,x 번갈아 나오게 하고, 승자를 가리기 위해 9개 블럭의 상태를 동시에 확인해야함.여러 하위 컴포넌트로 부터 데이터를 모으거나, 하위 컴포넌트들이 서로 통신하기 원하면 상위컴포넌트로 state를 이동시킴.상위 컴포컨트는 props를 통해 하위 컴포넌트로 state를 전달해 줄 수 있다. 12345678910111213141516171819202122232425262728293031323334353637class Board extends React.Component { constructor(props) { super(props); this.state = { squares: Array(9).fill(null), }; } renderSquare(i) { return &lt;Square value={i} /&gt;; } render() { const status = 'Next player: X'; return ( &lt;div&gt; &lt;div className=\"status\"&gt;{status}&lt;/div&gt; &lt;div className=\"board-row\"&gt; {this.renderSquare(0)} {this.renderSquare(1)} {this.renderSquare(2)} &lt;/div&gt; &lt;div className=\"board-row\"&gt; {this.renderSquare(3)} {this.renderSquare(4)} {this.renderSquare(5)} &lt;/div&gt; &lt;div className=\"board-row\"&gt; {this.renderSquare(6)} {this.renderSquare(7)} {this.renderSquare(8)} &lt;/div&gt; &lt;/div&gt; ); }} 지금 board의 renderSquare매서드는 아래와 같다.1234renderSquare(i) { return &lt;Square value ={i} /&gt;;} Square에 value prop를 전달하도록 수정한다123renderSquare(i) { return &lt;Square value={this.state.squares[i]} /&gt;; } 12345678renderSquare(i) { return ( &lt;Square value={this.state.squares[i]} onClick={() =&gt; this.handleClick(i)} /&gt; );} 123456789class Square extends React.Component { render() { return ( &lt;button className=\"square\" onClick={() =&gt; this.props.onClick()}&gt; {this.props.value} &lt;/button&gt; ); }} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Board extends React.Component { constructor(props) { super(props); this.state = { squares: Array(9).fill(null), }; } handleClick(i) { const squares = this.state.squares.slice(); squares[i] = 'X'; this.setState({squares: squares}); } renderSquare(i) { return ( &lt;Square value={this.state.squares[i]} onClick={() =&gt; this.handleClick(i)} /&gt; ); } render() { const status = 'Next player: X'; return ( &lt;div&gt; &lt;div className=\"status\"&gt;{status}&lt;/div&gt; &lt;div className=\"board-row\"&gt; {this.renderSquare(0)} {this.renderSquare(1)} {this.renderSquare(2)} &lt;/div&gt; &lt;div className=\"board-row\"&gt; {this.renderSquare(3)} {this.renderSquare(4)} {this.renderSquare(5)} &lt;/div&gt; &lt;div className=\"board-row\"&gt; {this.renderSquare(6)} {this.renderSquare(7)} {this.renderSquare(8)} &lt;/div&gt; &lt;/div&gt; ); }} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145function Square(props) { return ( &lt;button className=\"square\" onClick={props.onClick}&gt; {props.value} &lt;/button&gt; );}class Board extends React.Component { renderSquare(i) { return ( &lt;Square value={this.props.squares[i]} onClick={() =&gt; this.props.onClick(i)} /&gt; ); } render() { return ( &lt;div&gt; &lt;div className=\"board-row\"&gt; {this.renderSquare(0)} {this.renderSquare(1)} {this.renderSquare(2)} &lt;/div&gt; &lt;div className=\"board-row\"&gt; {this.renderSquare(3)} {this.renderSquare(4)} {this.renderSquare(5)} &lt;/div&gt; &lt;div className=\"board-row\"&gt; {this.renderSquare(6)} {this.renderSquare(7)} {this.renderSquare(8)} &lt;/div&gt; &lt;/div&gt; ); }}class Game extends React.Component { constructor(props) { super(props); this.state = { history: [ { squares: Array(9).fill(null) } ], stepNumber: 0, xIsNext: true }; } handleClick(i) { const history = this.state.history.slice(0, this.state.stepNumber + 1); const current = history[history.length - 1]; const squares = current.squares.slice(); if (calculateWinner(squares) || squares[i]) { return; } squares[i] = this.state.xIsNext ? \"X\" : \"O\"; this.setState({ history: history.concat([ { squares: squares } ]), stepNumber: history.length, xIsNext: !this.state.xIsNext }); } jumpTo(step) { this.setState({ stepNumber: step, xIsNext: (step % 2) === 0 }); } render() { const history = this.state.history; const current = history[this.state.stepNumber]; const winner = calculateWinner(current.squares); const moves = history.map((step, move) =&gt; { const desc = move ? 'Go to move #' + move : 'Go to game start'; return ( &lt;li key={move}&gt; &lt;button onClick={() =&gt; this.jumpTo(move)}&gt;{desc}&lt;/button&gt; &lt;/li&gt; ); }); let status; if (winner) { status = \"Winner: \" + winner; } else { status = \"Next player: \" + (this.state.xIsNext ? \"X\" : \"O\"); } return ( &lt;div className=\"game\"&gt; &lt;div className=\"game-board\"&gt; &lt;Board squares={current.squares} onClick={i =&gt; this.handleClick(i)} /&gt; &lt;/div&gt; &lt;div className=\"game-info\"&gt; &lt;div&gt;{status}&lt;/div&gt; &lt;ol&gt;{moves}&lt;/ol&gt; &lt;/div&gt; &lt;/div&gt; ); }}// ========================================ReactDOM.render(&lt;Game /&gt;, document.getElementById(\"root\"));function calculateWinner(squares) { const lines = [ [0, 1, 2], [3, 4, 5], [6, 7, 8], [0, 3, 6], [1, 4, 7], [2, 5, 8], [0, 4, 8], [2, 4, 6] ]; for (let i = 0; i &lt; lines.length; i++) { const [a, b, c] = lines[i]; if (squares[a] &amp;&amp; squares[a] === squares[b] &amp;&amp; squares[a] === squares[c]) { return squares[a]; } } return null;}","link":"/2019/08/06/tec/react/react1/"},{"title":"[React 교과서] 4장 React 컴포넌트의 객체 상태","text":"리엑트 교과서를 정리한 내용입니다. 리엑트에서 가장 중요한 부분이다. 4.1 React컴포넌트의 상태란?React의 상태는 컴포넌트의 변경 가능한 데이터 저장소이다.컴포넌트를 속성과 상태가 있는 함수라고 생각하면 함수의 결과가 UI표현(뷰)이다.속성과 상태는 모두 뷰를 갱신하기 위해 사용하지만 목적이 다름. 상태:상태는 이름을 활용하여 접근함. this.state 객체속성 ex) this.state.inputFileValue뷰의 랜더링이 갱신될 때 동적 정보를 출력하기 위해 사용됨.관련된 부분만 갱신됨. 아래 안티 패턴 예시상태 외의 다른 값을 변경해도 뷰를 갱신할 수 없다.123456789101112131415161718let inputValue ='Texas'class Autocomplete extends React.Component { updateValues(){ //--사용자 입력에 의해 실행됨 this.props.inputValue = 'California' inputValue ='California' this.inputValue='California' } render(){ return( &lt;div&gt; {this.props.inputValue} {inputValue} {this.inputValue} &lt;/div&gt; ) }} 속성은 부모 컴포넌트에서 새로운 값을 전달하면 뷰를 갱신하여 현재 다루는 자식 컴포넌트의 새로운 인스턴스를 생성함.해당 자식 컴포넌트의 컨텍스트내에서 this.props.inputValue=’California’로 변경해도 소용이 없음! 4.2 상태 객체 다루기4.2.1 상태 객체에 접근하기맴버변수로 this 를 통해 접근 가능. this.state.name와 같은 방식으로 접근.render()에서 this.state를 랜더링 할 수 있음. ex) {this.state.inputFieldValue} 현재 시간 출력하는 시계 구현하기 폴더 구조 /clock index /jsx script.jsx clock.jsx /js script.js clock.js react.js react-dom.js 1234567891011class Clock extends React.Component{ render(){ return &lt;div&gt;{this.state.currentTime}&lt;/div&gt; }}ReactDOM.render( &lt;Clock/&gt; document.getElementById('content')) 위와 같이 하면 ‘currentTime’ 값이 null이라는 오류가 발생한다.속성과 달리 상태는 부모 객체에서 설정하는것이 아니고 render()안에서 setState를 실행 할 수도 없다. 4.2.2 초기 상태 설정하기초기 상태를 설정하려면 React.Component를 사용하는 ES6클래스의 생성자에서 this.state를 선언함. 반드시 super()에 속성을 전달하여 실행한다.123456789class MyFancyComponent extends React.Component{ constructor(props){ super(props) this.state = {...} } render(){ ... }} 초기 상태를 설정하면서 다른 로직도 추가 가능.ex) new Date()를 사용하여 currentTime 값을 설정함. toLocaleString()을 사용하면 상용자 위치에 맞는 적절한 날짜시간 형식을 보여줄 수 있음. 1234567class Clock extends React.Component{ constructor(props){ super(props) this.state={currentTime: (new DAte()).toLocaleString('en')} } ...} 초기 상태 주의사항 this.state는 반드시 객체여야함. 생성자 메서드의 이름은 반드시 constructor로 함. 부며 클래스가 있는 클래스에서 construtcor()매서드를 생성하면 항상 super()를 호출함. 상속으로 클래스를 구현하면 constructor()매서드를 따로 작성하지 않으면 super()를 호출한것으로 가정함. constructor()메서드 내에서 한번만 this.state로 직접 상태를 선언하고 그 외 부분에서는 this.stat=…로 직접 상태 선언하지 않는다. 4.2.3 상태 갱신하기클래스 매서드인 this.setState(data, callback)를 사용하면 상태 변경 가능.data를 현재 상태에 병합하고 render()을 호출, 이후 callback함수 실행됨.setState()가 비동기로 작동함. 시계를 시작하려면 setInterval()을 한번 호출해야함.123456789101112131415161718192021class Clock extends React.Component{ counstructor(props){ super(props) this.lauchClock() this.state ={ currentTime: (new DAte()).toLocaleString('en') } } launchClock(){ setInterval(()=&gt; { console.log('Updating time...') this.setState({ currentTime: (new Date()).toLocaleString('en') }) }, 1000) } render() { console.log('Rendering Clock...') return &lt;div&gt;{this.state.currentTime}&lt;/div&gt; }} setState()로 상태를 교체할때 상태 항목이 여러개 있으면 명시해준것만 바뀌고 나머진 값이 그대로임.setState()가 render()를 실행시킴. 4.3 상태 객체와 속성상태 객체와 속성은 모두 클래스의 맴버이며 각각 this.state와 this.props를 말함. 상태 객체 vs 속성 객체 상태 객체는 변경가능, 속성 객체는 변경 불가능. 상태는 해당 컴포넌트 자체에서 정의, 속성은 부모 컴포넌트에서 전달(부모컴포넌트에서만 값을 변경 가능함). 상태는 컴포넌트에서 설정되고 갱신, 속성은 뷰 생성시에 정해지고 변경안됨. 4.4 상태비저장 컴포넌트 상태비저장 컴포넌트는 상태 객체가 없고 이벤트 또는 메서드를 갖지 않음. 상태비저장 컴포넌트의 목적은 뷰를 랜더링 하는것 뿐임. 속성을 전달받아 처리. 예측하기 편해서 이해, 유지보수, 디버깅이 편함.=&gt; 상태비저장컴포넌트 많이 사용하고 상태저장컴포넌트는 적게 사용하는게 바람직함. 아래는 상태비저장 컴포넌트 예제12345class HelloWorld extends React.Component{ render(){ return &lt;h1{...this.props}&gt; Hello{ this.props.frameworkName} world!!!&lt;/h1&gt; }} 상태가 필요하지 않으면 함수로 선언하면됨.12345678910functipn Link(props){ return &lt;a href ={props.href} target=\"_blank\" className=\"btn btn-primary\"&gt; {props.text}&lt;/a&gt;}ReactDOM.render( &lt;Link text ='Buy React Quickly' href ='https://www.manning.com/books/react-quickly' /&gt;, document.getElementById('content')) 123456789const Link = (props)=&gt;{ return ( &lt;href={props.href} target =\"_blank\" className=\"btn btn-primary\" &gt; {props.text} &lt;/a&gt; )} 상태비저장 컴포넌트는 상태를 가질 수 없지만 propTypes와 defaultProps를 프로퍼티로 가질 수 있다.12345678910function Link (props){ return &lt;a href = {props.href} target=\"_blank\" className=\"btn btn-primary\"&gt; {props.text} &lt;/a&gt;}Link.propTypes={...}Link.defaultProps={...} 4.5 상태비저장 컴포넌트와 상태저장 컴포넌트의 비교HTML 렌더링을 처리하는것으로 충분한 경우 상태비저장 컴포포넌트가 더 선언적이고 작동이 잘됨. 상태를 사용해야 하는 경우 UI 상태, 상호작용, 서버에서 데이터 불러오는것 등 을 관리하려면 상태저장 컴포넌트를 활용한다. 아날로그와 디지털 방식으로 노출하는 시계 프로젝트 구조/clock-analog-digital /jsx analog-display.jsx clock.jsx digital-display.jsx script.jsx /js analog-display.js clock.js digital-display.js script.js react.js react-dom.js / index.html 12345678...render() { console.log('Rendering...') return &lt;div&gt; &lt;AnalogDisplay time={this.state.currentTime}/&gt; &lt;DigitalDisplay time={this.state.currentTime}/&gt; &lt;/div&gt;} 123const DigitalDisplay = function(props){ return &lt;div&gt;{props.time}&lt;/div&gt;} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657const AnalogDisplay = function (props) { let date = new Date(props.time); let dialStyle = { position: 'relative', top: 0, left: 0, width: 200, height: 200, borderRadius: 20000, borderStyle: 'solid', borderColor: 'black' }; let secondHandStyle = { position: 'relative', top: 100, left: 100, border: '1px solid red', width: '40%', height: 1, transform: 'rotate(' + (date.getSeconds() / 60 * 360 - 90).toString() + 'deg)', transformOrigin: '0% 0%', backgroundColor: 'red' }; let minuteHandStyle = { position: 'relative', top: 100, left: 100, border: '1px solid grey', width: '40%', height: 3, transform: 'rotate(' + (date.getMinutes() / 60 * 360 - 90).toString() + 'deg)', transformOrigin: '0% 0%', backgroundColor: 'grey' }; let hourHandStyle = { position: 'relative', top: 92, left: 106, border: '1px solid grey', width: '20%', height: 7, transform: 'rotate(' + (date.getHours() / 12 * 360 - 90).toString() + 'deg)', transformOrigin: '0% 0%', backgroundColor: 'grey' }; return React.createElement( 'div', null, React.createElement( 'div', { style: dialStyle }, React.createElement('div', { style: secondHandStyle }), React.createElement('div', { style: minuteHandStyle }), React.createElement('div', { style: hourHandStyle }) ) );};","link":"/2019/08/28/tec/react/react5/"},{"title":"[React 교과서] 3장 JSX","text":"리엑트 교과서를 정리한 내용입니다. 3.1 JSX의 정의와 장점함수 호출과 객체 생성을 위한 문법적 편의를 제공하는 자바스크립트의 확장. JSX가 React에 필수적이지는 않지만 같이 사용할것이 권장됨 개발자 경험 개선: 코드를 읽기 쉽다 팀의 생산성 향상: HTML과 비슷하여 친숙함 문법 오류와 코드량 감소 JSX코드 예제 12345&lt;div&gt; &lt;HelloWorld/&gt; &lt;br/&gt; &lt;a href = \"https://eunii.github.io\"&gt; eunii blog&lt;/a&gt;&lt;/div&gt; 위의 코드 자바스크립트로 변경한 예제 1234567891011React.createElement( \"div\", null, React.createElement(HellowWorld, null), React.createElement(\"br\", null), React.createElement( \"a\", {href : \"https://eunii.github.io\"}, \"eunii blog\" ),) 자바스크립트 코드 사이에 &lt;&gt;가 있으면 처음에는 어색하지만. React.createBlement(NAME, …) 대신 을 사용하는것이 훨씬 직관적이고 편리하다.JSX를 사용하려면 브라우저에서 실행하기 전에 컴파일 또는 트랜스파일 과정을 거쳐 일반적 자바스크립트 파일로 변환해야한다. 3.2 JSX의 이해3.2.1 JSX로 React 엘리먼트 생성하기12345React.createElement( name, {key1: value1, key2: vlaue2, ...}, child1, child2, ..., childN) 위의 코드를 JSX로 바꾸면 아래와 같다123456&lt;name key1=value1 key2 value2 ...&gt; &lt;child1/&gt; &lt;child2/&gt; ... &lt;childN/&gt;&lt;/name&gt; 계속 공부해 왔던 HelloWorld예제를 자바스크립트로 작성하면1234ReactDOM.render( React.createElement('h1', null, 'Hello world!'), document.getElementById('content')) 위의 코드를 JSX로 작성하면1234ReactDOM.render( &lt;h1&gt;Hello world!&lt;/h1&gt; document.getElementById('content')) JSX문법으로 작성한 객체도 변수에 저장 가능하다.harmony12345let helloWorldReactElement = &lt;h1&gt;Hello world!&lt;/h1&gt;ReactDOM.render( helloWorldReactElement, document.getElementById('content')) 3.2.2 React 컴포넌트에 JSX 사용하기JSX 태그는 표준 HTML 태그 이름이기도 하다. 컴포넌트를 다룰 때에도 같은 문법을 사용하고 컴포넌트 클래스 이름이 대문자로 시작한다.1234567891011121314151617- JSX를 이용해서 생성한 HelloWorld클래스```jsclass HelloWorld extends React.Component{ render(){ return( &lt;div&gt; &lt;h1&gt; 1. Hello world!&lt;/h1&gt; &lt;h2&gt; 2. Hello world!&lt;/h1&gt; &lt;/div&gt; ) }}ReactDOM.render( &lt;HelloWorld/&gt; document.getElementById(&apos;content&apos;)) 3.2.3 JSX에서 변수 출력하기컴포넌트를 작송할때, 약간의 코드로 자체적으로 뷰를 변경할 수 있는 코드를 만들기. ex) 현재 시간/날짜를 사용하기JSX없이 React만 사용하면 +를 이용해 연결하거느 ‘와 ${varName}로 표시한 문자열 탬플릿을 사용할 수 있다. (템플릿 리터럴) 123456class DateTimeNow extends React.Component{ render(){ let dateTimeNow = new Date().toLocaleDateString() return &lt;span&gt; Hello {this.props.userName}, current date and time is {dateTimeNow}.&lt;/span&gt; }} 12345678910111213let helloWorldReactElement = &lt;h1&gt;Hello world!&lt;/h1&gt;class HelloWorld extends React.Component { render() { return &lt;div&gt; {helloWorldReactElement} {helloWorldReactElement} &lt;/div&gt; }}ReactDOM.render( &lt;HelloWorld/&gt;, document.getElementById('content')) 3.2.4 JSX에서 속성 사용하기사용자 계정에 연결할 컴포넌트를 만들때, href와 title의 값은 사용자에 따라 달라져야 하므로 하드 코딩할 수 없다.123456789101112class ProfileLint extends React.Component{ render(){ return ( &lt;a href ={this.props.url} title ={this.props.lable} target=\"_blank\"&gt; Profile &lt;/a&gt; ) }} 위의 코드에서 속성값은 ProfileLink 생성시에 정의된다. ProfileLink를 생성하는 부모 컴포넌트에서 이 값을 전달함.1&lt;ProfileLink url=&apos;/user/azat&apos; label=&apos;Profile for azat&apos; /&gt; 가끔 사용자 지정 데이터를 속성으로 추가할 때가 있다. DOM요소에 속성으로 넣는것은 흔히 사용하지만 HTML 비표준 속성에 데이터를 저장하는 것은 안티패턴으로 여겨진다.DOM에서 데이터를 가져오는것은 메모리 상의 가상 저장소에서 데이터를 가져오는것보다 느리다. 데이터를 반드시 HTML요소의 속성으로 저장해야 하는 경우는 data-*속성을 사용한다.1&lt;li data-react-is-awesom={this.reactIsAwesome}&gt; React is awesome!&lt;/li&gt; 위의 경우reactIsAwesome 값이 true라면 아래와 같이 HTML이 렌더링 된다1&lt;li data-react-is-awesom=\"true\"}&gt; React is awesome!&lt;/li&gt; 하지만 아래와 같이 비표준 HTML속성을 전달하면 HTML속성이 렌더링 되지 않는다.12&lt;li react-is-awesom={this.reactIsAwesome}&gt; React is awesome!&lt;/li&gt;&lt;li reactIsAwesom={this.reactIsAwesome}&gt; React is awesome!&lt;/li&gt; 위의 결과는 아래와 같다12&lt;li&gt; React is awesome!&lt;/li&gt;&lt;li&gt; React is awesome!&lt;/li&gt; 아것대신 this.props를 통해서 입력한데이터는 모든 속성에 접근할 수 있다. 모든 속성을 전달해야 한다면 …를 사용할 수 있다.({…this.props) 1234567891011121314151617181920212223class HelloWorld extends React.Component { render() { return &lt;h1 {...this.props}&gt;Hello {this.props.frameworkName} world!!!&lt;/h1&gt; }}ReactDOM.render( &lt;div&gt; &lt;HelloWorld id='ember' frameworkName='Ember.js' title='A framework for creating ambitious web applications.'/&gt; &lt;HelloWorld id='backbone' frameworkName='Backbone.js' title='Backbone.js gives structure to web applications...'/&gt; &lt;HelloWorld id='angular' frameworkName='Angular.js' title='Superheroic JavaScript MVW Framework'/&gt; &lt;/div&gt;, document.getElementById('content')) 3.2.5 React 컴포넌트 메서드 생성하기React 컴포넌트에 애플리케이션을 위한 메서드를 자유롭게 추가할 수 있다.123456789class Content extends React.Component { getUrl(){ return 'http://webapplog.com' } render(){ ... }} {}안에 클래스 메서드를 호출 하는 방식으로 사용한다.123456789101112class Content extends React.Component { getUrl() { return 'http://webapplog.com' } render() { return ( &lt;div&gt; &lt;p&gt;Your REST API URL is: &lt;a href={this.getUrl()}&gt;{this.getUrl()}&lt;/a&gt;&lt;/p&gt; &lt;/div&gt; ) }} 3.2.6 JSX의 if/else처리 유저 세션에 따른 렌더링 처리 예시(자바스크립트)1234567...render(){ if(user.session) return &lt;a href=\"/logout\"&gt; Logout&lt;/a&gt; else return &lt;a href=\"/login\"&gt; Login&lt;/a&gt;} JSX로 3가지 방법 표현법123456789101112131415161718192021222324252627282930313233//방법1 변수render(){ let link if(this.props.user.session){ link = &lt;a href=\"/logout\"&gt; Logout&lt;/a&gt; else link = &lt;a href=\"/login\"&gt; Login&lt;/a&gt; return &lt;div&gt;{link}&lt;/div&gt; }}// 방법 2 표현식render(){ let link = (sessionFlag) =&gt; { if(sessionFlag){ return &lt;a href=\"/logout\"&gt; Logout&lt;/a&gt; else return &lt;a href=\"/login\"&gt; Login&lt;/a&gt; } return &lt;div&gt;{link(this.props.user.session})}&lt;/div&gt;}//방법 3 삼항연산자render(){ return( &lt;div&gt; {(this.props.uwer.session) ? &lt;a href=\"/logout\"&gt; Logout&lt;/a&gt; : &lt;a href=\"/login\"&gt; Login&lt;/a&gt; } &lt;/div&gt; ) } return 문 이전에 JSX 외부에 변수를 선언한 후 JSX 내부에서 {}를 사용하여 출력한다 return 문 이전에 JSX외부에서 값을 반환하는 함수 표현식을 선언한 후 JSX내부의 {}에서 실행한다 삼항연산자를 사용한다 JSX 내부에서 즉시 실행함수를 사용한다. 3.2.7 JSX의 주석 작성 방법일반 자바스크립트 주석과 비슷하다. {}로 감싸서 작성한다. 3.3 Babel을 이용한 JSX 트랜스 파일러 설정하기JSX파일을 자바스크립트코드로 변환하는 과정을 트랜스파일레이션이라고 한다. Babel 명령줄 인터페이스 도구 Node.js 또는 브라우저 자바스크립트로 작성한 스크립트(API방식): babel-core 패키지를 이용해서 스크립트를 직성해 변환하는 방식 빌드 도구: Grunt, Gulp, Webpack도구에서 Babel을 플러그인으로 사용할 수 있다. 1. Node.js npm 설치3.4 React와 JSX의 까다로운 부분태그를 닫을 때 반드시 /를 넣어야 한다. 3.4.1 특수문자HTML엔터티코드를 사용하여 저작권 표시나 말바꿈표 따옴표 등을 사용할 수 있다. 1- ```mdash; 1234```js&lt;span&gt;&amp;copy;&amp;mdash;&amp;ldquo;&lt;/span&gt;&lt;input value =&quot;&amp;copy;&amp;mdash;&amp;ldquo;&quot;/&gt; 아래 코드는 작동하지 않는 오류 코드123var specialChars = \"&amp;copy;&amp;mdash;&amp;ldquo;\"&lt;span&gt;{specialChars}&lt;/span&gt;&lt;input value={specialChars}/&gt; 위험한 HTML구문에 대해서 자동으로 이스케이프를 적용함. 특수문자를 노출하려면 다음 방법중 하나를 선택한다. 배열로 출력해 여러개의 분자열로 분리 소스코드에 특수문자를 직접 복사해서 넣는다 특스문자를 \\u로 시작하는 이스케이프 시퀸스로 바꾼 후에 유니코드번호를 찾아 사용한다. String.fromCharCode(charCodeNumber)를 이용해서 유니코드 번호에서 문자로 변경한다 React 엘리먼트의 _html에 dangerouslySetInnerHTML을 이용하는 방법이 있으나 추천하지 않는다","link":"/2019/08/14/tec/react/react4/"},{"title":"[CH12. 쓰레드] 프로세스와 쓰레드","text":"1. 프로세스와 쓰레드프로세스(process)는 간단하게 말하면 실행중인 프로그램이다.프로그램 –실행–&gt; 프로세스프로세스는 데이터, 메모리등의 자원과 쓰레드로 구성되어있음.프로세스의 자원을 이용해서 실제 작업을 수행하는 것.모든 프로세스는 최소 하나 이상의 쓰레드가 존재. 둘 이상이면 멀티쓰레드 프로세스라한다. 멀티쓰레딩의 장점 CPU의 사용률을 향상시킴. 자원을 보다 효울적으로 사용할 수 있음. 사용자에 대한 응답성이 향상됨. 작업이 분리되어 코드가 간결해짐. 동기화(synhronization), 교착상태(deadlock)등을 고려해서 신중히 프로그래밍 해야함. 2. 쓰레드의 구현과 실행구현 방법 Thread클래스 상속 12345class MyThread extends Thread{ public void run(){ //Thread의 run()함수를 오버라이딩. }} Runnable인터페이스 구현(일반적인 방법) 12345class MyThread implements Runnable{ public void run(){ //추상메서드 run()을 구현 }} 123456789101112131415161718192021222324class ThreadEx1{ public static void main(String[] args){ ThreadEx1_1 t1 = new ThreadEx1_1(); Runnable r = new ThreadEx1_2(); Thread t2 = new Thread(r); }}class ThreadEx1_1 extends Thread{ public void run(){ for(int i = 0; i &lt; 5; i++) { System.out.println(getName()); } }}class ThreadEx1_2 implements Runnable{ public void run(){ for(int i = 0; i &lt; 5; i++) { System.out.println(Thread.currentThread().getName()); } }} 쓰레드 생성 후 start()를 호출해야 작업을 시작함.한번 사용한 쓰레드는 다시 재사용할 수 없다. 하나의 쓰레드에 한번의 start()만 호출 될 수 있음. 1234567891011ThreadEx1_1 t1 = new ThreadEx_1();t1.start();t.start();//이건 불가능``` ```javaThreadEx1_1 t1 = new ThreadEx1_1();t1.start();t1 = new ThreadEx1_1();t.start();//이건 가능 3. start()와 run() run()을 호출하는 것은 생성된 쓰레드를 실행하는 것이 아니라 단순히 클래스에속한 메서드를 하나 호출하는것. call stack run main start()을 호출하는 것은 새로운 쓰레드가 작업을 실행하는데 필요한 호출스택을 생성한 후 run()을 호출해서 생성된 호출스택에 run()이 저장되게 한다.모든 쓰레드는 독립적인 작업을 수행하기 위해 자신만의 호출스택을 필요로 하기 때문에 새로운 쓰레드를 생성하고 실행시킬때마다 새로운 호출스택이 생성되고 쓰레드가 종료되면 작업에 사용된 호출스택은 소멸된다. main메서드에서 쓰레드의 start메서드를 호출한다. start메서드는 쓰레드가 작업을 수행하는데 사용될 새로운 호출 스택을 생성한다. 생성된 호출스택에 run 메서드를 호출해서 쓰레드가 작업을 수행하도록 한다. 이제는 호츨스택이 2개이기때문에 스케줄러가 정한 순서에 으해 번갈아 가면서 실행된다. 실행중인 쓰레드가 하나도 없을때 프로그램은 종료된다. 4. 싱글쓰레드와 멀티쓰레드두개의 작업을 하나의 쓰레드로 하면 한 작업 끝난 후 다른 작업 끝.두개의 작업을 두개의 쓰레드로 하면 짧은시간동안 쓰레드 2개가 번갈아 가면서 작업을 수행해서 동시에 두 작업이 처리되는것과 같다고 느낌.CPU만 사용하는 계산 작업이면 멀티쓰레드가 전환하는 시간때문에 오히려 느림.CPU외 자원을 사용하는 경우 싱글쓰레드 프로세스 보다 멀티쓰레드프로세스가 더 효율적임.ex)외부기기에서 입출력 받는 경우123456789101112131415import javax.swing.JOptionPane;class ThreadEx6{ public static void main(String[] args) throws Exception{ String input = JOptionPanel.showInputDialog(\"아무 값이나 입력하세요.\"); System.out.println(\"입력하신 값은 \"+input+\"입니다.\"); for(int i = 10; i &gt; 0 ; i--) { System.out.println(i); try{ Thread.sleep(1000); }catch(Exception e){} } }} 위의 예는 입력을 받은 후 출력하기 때문에 사용자가 입력하는 동안에는 출력 작업이 일어나지 않는다.123456789101112131415161718192021222324import javax.swing.JOptionPane;class ThreadEx7{ public static void main(String[] args) throws Exception{ ThreadEx7_1 th1 = new ThreadEx7_1(); th1.start(); String input = JOptionPanel.showInputDialog(\"아무 값이나 입력하세요.\"); System.out.println(\"입력하신 값은 \"+input+\"입니다.\"); }}class ThreadEx7_1 extends Thread{ public void run(){ for(int i = 10; i &gt; 0 ; i--) { System.out.println(i); try{ Thread.sleep(1000); }catch(Exception e){} } }} 위의 코드는 입력받는 동안 출력되고 입력된 값이 출력되고 또 출력이 된다. 5. 쓰레드의 우선순위쓰레드에 우선순위(priority)의 멤버변수가 있다.우선순위의 범위는 1~10이고 숫자가 높을수록 더 우선순위가 높다.우선순위의 값은 상대적이다. 1,2와 8,9의 결과 값이 같다.우선순위는 쓰레드생성한 쓰레드로부터 상속받는다.main 메서드를 수행하는 쓰레드의 우선순위는 5.파일 다운로드와 채팅기능 중 채팅에 더 우선순위를 높여야 한다.123456void setPripority(int new Priority);int getPriority();public static final int MAX_PRIORITY =10;public static final int MIN_PRIORITY =1;public static final int NORM_PRIORITY = 5; 12345678910111213141516171819202122232425262728class ThreadEx9{ public static void main(String[] args) throws Exception{ ThreadEx9_1 th1 = new ThreadEx9_1(); ThreadEx9_2 th2 = new ThreadEx9_2(); th2.setPriority(7); System.out.println(\"입력하신 값은 \"+input+\"입니다.\"); th1.start(); th2.start(); }}class ThreadEx9_1{ public void run(){ for(int i = 0; i &lt; 300 ; i++) { System.out.println(\"-\"); for(int j = 0; j &lt; 1000000 ; j++) {} } }}class ThreadEx9_2{ public void run(){ for(int i = 0; i &lt; 300 ; i++) { System.out.println(\"|\"); for(int j = 0; j &lt; 1000000 ; j++) {} } }} 위 결과는 |가 먼저 끝나고, - 이 완료된다. 6. 쓰레드 그룹(thread group)서로 관련된 쓰레드를 그룹으로 다루기 위한것.폴더를 생성해서 관련된 파일을 묶어 관리하는것처럼 쓰레드도 그룹으로 묶어서 관리.쓰레드를 쓰레드 그룹에 포함시키려면 Thread생성자를 이용해야함12Thread(ThreadGroup group, String name)Thread(ThreadGroup gorup, Runnable target) 7. 데몬쓰레드(deamon thread)데몬쓰레드는 일반 쓰레드의 작업을 돕는 보조역할.일반쓰레드 작업이끝나면 데몬 쓰레드는 강제종료됨.ex) 가비지컬렉터, 위드프로세서 자동저장, 화면자동갱신무한루프와 조건문을 이용해서 실행 후 대기하고 있다가 특정 조건이 되면 작업 수행하고 다시 대기. 8. 쓰레드의 실행제어쓰레드 프로그램이 어렵게 느껴지는 건 동기화와 스케줄링때문임. 쓰레드 스케쥴링과 관련된 메서드 생성자/메서드 설명 void interupt() sleep()이나 join()에 의해 일시정지상태인 쓰레드를 실행대기상태로 만든다. 해당 쓰레드에서는 interuptedExcetption이 발생함으로써 일시정지상태를 벗어나게 된다. void join()void join(long millis) void join(long millis, int nanos) 지정된 시간동안 쓰레드가 실행되도록한다. 지정된 시간이 자나거나 작업이 종료되면 join()을 호출한 쓰레드로 다시 돌아와 실행을 계속한다. void resume() supend()에 의해 일시정지상태에 있는 쓰레드를 실행대기 상태로 만든다. static void sleep(long millis)static void sleep(long millis, int nanos) 지정된 시간( 천분의 일초 단위) 동안 쓰레드를 일시정지 시킨다. 지정한 시간이 지나고 나면 자동적으로 다시 실행대기가 된다. void stop() 쓰레드를 즉시 종료시킨다. 교착상태(dead-lock)에 빠지기 쉽기 때문에 deprecated되었다. void suspend() 쓰레드를 일시정지시킨다. resume()을 호출하면 다시 실행대기상태가 된다. satic void yield() 실행중에 다른 쓰레드에게 양보하고 실행대기상태가 된다. 쓰레드의 상태 상태 설명 NEW 쓰레드가 생성되고 아직 start()가 호출되지 않은 상태 RUNNABLE 실행 중 또는 실행 가능한 상태 BLOCKED 동기화 블럭에 의해서 일시정지된 상태(Lock이 풀릴때까지 기다리는 상태) WATING, TIMED_WATING 쓰레드의 작업이 종료되지는 않았지만 실행가능하지 않은 일시정지 상태. TIMED_WATEING은 일시정지시간이 지정된 경우를 의미한다. TERMINATED 쓰레드의 작업이 종료된 상태 쓰레드 생성하고 start()을 호출하면 실행대기열에 저장. 순서를 기다림. Quequ와같은 구조로 먼저 실행대기열에 들어온 쓰레드가 먼저 실행됨. 실행대기상태이다가 자기 차례가 오면 실행상태가 됨. 주어진 실행시간이 다되거나 yeild()를 만나면 다시 실행대기 상태가 되고 다음 차례의 쓰레드가 실행상태가 됨. 실행중 suspend(), sleep(), wait(), join(), I/O block에 의해 일시정지상태가 딜 수 있음. 지정된 일시정지 시간이 지나거나 notify(), reusme(), interrup()가 호출되면 일시정지 상태를 벗어나 다시 실행대기열에 들어가 순서를 기다림. 실행을 모두 마치거나 stop()이 호출되면 쓰레드는 소멸됨. join()을 사용한 예시 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667class ThreadEx13{ static long startTime=0; public static void main(String[] args) throws Exception{ ThreadEx13_1 th1 = new ThreadEx13_1(); ThreadEx13_2 th2 = new ThreadEx13_2(); th1.start(); th2.start(); startTime = System.currentTimeMillis(); try{ th1.join();//th1의 작업이 끝날때까지 기다린다. th2.join();//th2의 작업이 끝날때까지 기다린다. }catch (InterruptedException e){} System.out.println(\"소요시간:\" + (System.currentTimeMillis()- ThreadEx13.startTime)); }}class ThreadEx13_1{ public void run(){ for(int i = 0; i &lt; 300 ; i++) { System.out.println(\"-\"); } }//run()}class ThreadEx13_2{ public void run(){ for(int i = 0; i &lt; 300 ; i++) { System.out.println(\"|\"); } } //run()}``` join()을 사용하지 않으면 main 쓰레드는 바로 종료되지만, join()을 사용해서 th1과 th2의 작업이 마칠때까지 main쓰레드가 기다림 - 쓰레드가 순차적으로 실행되어야 할때 사용하는 예제. ```javaclass ThreadEx14{ static long startTime=0; public static void main(String[] args) throws Exception{ ThreadEx14_1 th1 = new ThreadEx14_1(); ThreadEx14_2 th2 = new ThreadEx14_2(); th1.start(); try{ th1.join(); }catch (InterruptedException e){} th2.start(); }}class ThreadEx14_1{ public void run(){ for(int i = 0; i &lt; 300 ; i++) { System.out.println(\"-\"); } }//run()}class ThreadEx14_2{ public void run(){ for(int i = 0; i &lt; 300 ; i++) { System.out.println(\"|\"); } }} 아래 코드는 th1, th2, Main쓰레드 순으로 종료됨 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class ThreadEx15{ static long startTime=0; public static void main(String[] args) throws Exception{ ThreadEx15_1 th1 = new ThreadEx15_1(); ThreadEx15_2 th2 = new ThreadEx15_2(); th1.start(); th2.start(); try{ th1.sleep(); }catch (InterruptedException e){} System.out.println(\"&lt;&lt;main종료&gt;&gt;\"); }}class ThreadEx15_1{ public void run(){ for(int i = 0; i &lt; 300 ; i++) { System.out.println(\"-\"); } System.out.println(\"&lt;&lt;TH1종료&gt;&gt;\"); }//run()}class ThreadEx15_2{ public void run(){ for(int i = 0; i &lt; 300 ; i++) { System.out.println(\"|\"); } System.out.println(\"&lt;&lt;TH2종료&gt;&gt;\"); } //run()}``` 왜 th1이 sleep()으로 잠들어있어도 가장 먼저 종료될까? sleep()이 항상 현재 실행중인 쓰레드에 대해 작동해서 th1.sleep()호출해도 main메서드를 실행하는 main쓰레드가 영향받는다. static으로 선언되어 있어서 참조변수로 sleep()을 호출하기 보다는 Thread.sleep()이렇게 호츨해야 함.## 9. 쓰레드의 동기화 멀티쓰레드는 여러 쓰레드가 같은 프로세스내의 자원을 공유하기 때문에 데이터가 원래 의도했더것과는 다르게 변경 될 수 있음. ### 9.1 synchorized를 이용한 동기화 공유 데이터에 lock을 걸어 먼저 작업중이던 쓰레드가 작업을 완전히 마칠때까지는 다른 쓰레드에게 제어권이 넘어가도 데이터가 변경되지 않도록 보호함. - synchronized 사용방법 두가지. 가능하면 메서드에 synchronized를 사용하는 메서드 단위 동기화를 권장함. ```java// 1. 특정한 객체에 lock을 걸고자 할때 sysnchronized(객체의 참조변수){ }// 2. 메서드에 lock을 걸고자 할때 public void synchronized void calcSum(){ } synchronized를 이용해서 객체를 동기화 하면 쓰레드가 교착상태에 빠질 수 있다.교착상태란 구 쓰레드가 lock이 된 상태로 서로 lock가 풀리기를 무한정 기다리게 되는상황. 1234567891011121314151617181920212223class ThreadEx21 { public static void main(String[] args){ RunnbaleImpl r = new RunnableImpl(); Thread th1 = new Thread(r); Thread th2 = new Thread(r); th1.start(); th2.start(); }}class RunnableTmpl implements Runnable { int iv = 0; public void run(){ int lv = 0; String name = Thread.currentThread().getName(); while(lv&lt;3){ System.out.println(name+\"Local var: \"+ ++lv); System.out.println(name+\"Instance var: \"+ ++iv); System.out.println(); } }} 실행결과1234567891011121314151617Thread-0 Local var: 1Thread-0 Instance var: 1 Thread-0 Local var: 2Thread-0 Instance var: 2 Thread-0 Local var: 3Thread-0 Instance var: 3 Thread-0 Local var: 1Thread-0 Instance var: 4 Thread-0 Local var: 2Thread-0 Instance var: 5 Thread-0 Local var: 3Thread-0 Instance var: 6 여기서 인스턴스변수 iv는 main, th1, th2 쓰레드 모두 접근이 가능함.(쓰레드간의 변수 공유) lv는 지역변수라 각 쓰레드 스택내에서 생성되어 공유되지 않는다. 다음은 동기화가 잘 되지 않아 데이터 값이 변형된 예제.123456789101112131415161718192021222324252627282930class ThreadEx24{ public static void main(String[] args){ RunnbaleImpl r = new RunnableImpl(); Thread th1 = new Thread(r); Thread th2 = new Thread(r); th1.start(); th2.start(); }}class Account{ int balance =1000; public void withdraw (int money){ if(balance&gt;=money){ try{ Thread.sleep(1000);} catch(Exception e){} balance -=money; } }//withdraw}class RunnableEx24 implements Runnable{ Account acc = new Account(); public void run(){ while(acc.balance &gt; 0){ //100, 200, 300중의 한 값을 임의로 선택해서 출금 int money = (int)(Math.random()*3+1)*100; acc.withdraw(money); System.out.println(\"balance:\"+acc.balance); } }//run()} 실행 결과123456789101112131415161718192021222324252627282930balance:700balance:400balance:200balance:0balance:-100``` 잔고(balance)가 임의의 출금금액(money)보다 클 경우에만 출금하도록 되어있는데 잔고에 -100이 나왔음. if조건문 통과하고 출금직전에 다른쓰레드가 끼어들어서 먼저 출금했기때문이다. if문과 출금하는 기능은 하나로 synchronized되어야 한다. ```javapublic synchronized void withdraw (int money){ if(balance&gt;=money){ try{ Thread.sleep(1000);} catch(Exception e){} balance -=money; }}//withdraw``` ```javapublic void withdraw (int money){ synchronized(this){ if(balance&gt;=money){ try{ Thread.sleep(1000);} catch(Exception e){} balance -=money; } }}//withdraw 9.2 wait()과 notify() 쓰레드를 동기화 할때 효율을 높이기 위해 사용할 수 있다. 한쓰레드가 lock걸려 다른 쓰레드는 lock이 풀릴때까지 기다려야 되는 상황이 있음. 쓰레드에 lock을 걸는것 대신에 wait()을 호출해서 다른 쓰레드에 제어권을 넘겨주고 대기상태로 기다리다가 다른쓰레드에 의해 notify()가 호출되면 다시 실행상태가 되도록 함 wait()과 notify()는 Object클래스에서 정의되서 모든 객체에서 호출이 가능함. 동기화 블록 내에서만 사용가능. 쓰레드가 wait()을 호출하면 그때까지 걸어 놓은 lock을 풀고 대기실에 들어가기 됨. notify()는 객체의 wating pool에 있는 쓰레드 중 하나만 깨움. wait(), notify(), notifyAll() Object에 정의 되어있다. 동기화 블록(synchronized)내에서만 사용할 수 있다. 보다 효율적인 동기화를 가능하게 한다. 12345678910111213141516class Account{ int balance =1000; public synchronized void withdraw (int money){ if(balance&gt;=money){ try{ wait(); } catch(Exception e){} balance -=money; } }//withdraw}public synchronized void desposit(int money){ balance += money; notify();}","link":"/2019/05/08/tec/java/java11/"}],"tags":[{"name":"tec","slug":"tec","link":"/tags/tec/"},{"name":"alogrithm","slug":"alogrithm","link":"/tags/alogrithm/"},{"name":"정렬","slug":"정렬","link":"/tags/정렬/"},{"name":"알고리즘","slug":"알고리즘","link":"/tags/알고리즘/"},{"name":"시간복잡도","slug":"시간복잡도","link":"/tags/시간복잡도/"},{"name":"재귀함수","slug":"재귀함수","link":"/tags/재귀함수/"},{"name":"자료구조","slug":"자료구조","link":"/tags/자료구조/"},{"name":"blog","slug":"blog","link":"/tags/blog/"},{"name":"jekyll","slug":"jekyll","link":"/tags/jekyll/"},{"name":"github","slug":"github","link":"/tags/github/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"google-analytics","slug":"google-analytics","link":"/tags/google-analytics/"},{"name":"Markdown","slug":"Markdown","link":"/tags/Markdown/"},{"name":"마크다운","slug":"마크다운","link":"/tags/마크다운/"},{"name":"disque","slug":"disque","link":"/tags/disque/"},{"name":"java의 정석","slug":"java의-정석","link":"/tags/java의-정석/"},{"name":"network","slug":"network","link":"/tags/network/"},{"name":"공유기","slug":"공유기","link":"/tags/공유기/"},{"name":"도메인","slug":"도메인","link":"/tags/도메인/"},{"name":"noip","slug":"noip","link":"/tags/noip/"},{"name":"react","slug":"react","link":"/tags/react/"},{"name":"프레임워크","slug":"프레임워크","link":"/tags/프레임워크/"},{"name":"리엑트","slug":"리엑트","link":"/tags/리엑트/"},{"name":"spring","slug":"spring","link":"/tags/spring/"},{"name":"framework","slug":"framework","link":"/tags/framework/"},{"name":"sql","slug":"sql","link":"/tags/sql/"},{"name":"여행","slug":"여행","link":"/tags/여행/"},{"name":"유럽","slug":"유럽","link":"/tags/유럽/"},{"name":"아이슬란드","slug":"아이슬란드","link":"/tags/아이슬란드/"},{"name":"오로라","slug":"오로라","link":"/tags/오로라/"},{"name":"숙소","slug":"숙소","link":"/tags/숙소/"},{"name":"websocket","slug":"websocket","link":"/tags/websocket/"},{"name":"소켓통신","slug":"소켓통신","link":"/tags/소켓통신/"},{"name":"spirng boot","slug":"spirng-boot","link":"/tags/spirng-boot/"},{"name":"눈","slug":"눈","link":"/tags/눈/"},{"name":"빙하","slug":"빙하","link":"/tags/빙하/"},{"name":"골든서클","slug":"골든서클","link":"/tags/골든서클/"},{"name":"폭포","slug":"폭포","link":"/tags/폭포/"},{"name":"해변","slug":"해변","link":"/tags/해변/"},{"name":"미국","slug":"미국","link":"/tags/미국/"},{"name":"옐로우스톤","slug":"옐로우스톤","link":"/tags/옐로우스톤/"},{"name":"무지개","slug":"무지개","link":"/tags/무지개/"},{"name":"java","slug":"java","link":"/tags/java/"}],"categories":[{"name":"tec","slug":"tec","link":"/categories/tec/"},{"name":"alogrithm","slug":"tec/alogrithm","link":"/categories/tec/alogrithm/"},{"name":"blog","slug":"tec/blog","link":"/categories/tec/blog/"},{"name":"java","slug":"tec/java","link":"/categories/tec/java/"},{"name":"network","slug":"tec/network","link":"/categories/tec/network/"},{"name":"react","slug":"tec/react","link":"/categories/tec/react/"},{"name":"spring","slug":"tec/spring","link":"/categories/tec/spring/"},{"name":"sql","slug":"tec/sql","link":"/categories/tec/sql/"},{"name":"trip","slug":"trip","link":"/categories/trip/"},{"name":"island","slug":"trip/island","link":"/categories/trip/island/"},{"name":"america","slug":"trip/america","link":"/categories/trip/america/"}]}